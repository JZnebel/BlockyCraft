---
// 3D Voxel Model Viewer using Three.js
interface Props {
  containerId?: string;
}

const { containerId = 'voxel-viewer' } = Astro.props;
---

<div class="relative w-full h-[600px]">
  <div id={containerId} class="w-full h-full bg-gradient-to-br from-navy/5 to-aqua/5 rounded-xl border-2 border-gray-200"></div>

  <!-- Camera Controls (Bottom Right) -->
  <div class="absolute bottom-4 right-4 flex flex-col gap-2 z-10">
    <button
      id={`${containerId}-focus-btn`}
      class="bg-white hover:bg-gray-100 text-gray-700 font-semibold py-2 px-3 rounded-lg shadow-md border border-gray-300 transition-colors flex items-center gap-1 text-sm"
      title="Focus on model (F)"
    >
      <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor">
        <path d="M10 12a2 2 0 100-4 2 2 0 000 4z" />
        <path fill-rule="evenodd" d="M.458 10C1.732 5.943 5.522 3 10 3s8.268 2.943 9.542 7c-1.274 4.057-5.064 7-9.542 7S1.732 14.057.458 10zM14 10a4 4 0 11-8 0 4 4 0 018 0z" clip-rule="evenodd" />
      </svg>
      Focus
    </button>
    <div class="flex gap-2">
      <button
        id={`${containerId}-zoom-out-btn`}
        class="bg-white hover:bg-gray-100 text-gray-700 font-semibold py-2 px-3 rounded-lg shadow-md border border-gray-300 transition-colors"
        title="Zoom out (-)"
      >
        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor">
          <path fill-rule="evenodd" d="M3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd" />
        </svg>
      </button>
      <button
        id={`${containerId}-zoom-in-btn`}
        class="bg-white hover:bg-gray-100 text-gray-700 font-semibold py-2 px-3 rounded-lg shadow-md border border-gray-300 transition-colors"
        title="Zoom in (+)"
      >
        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor">
          <path fill-rule="evenodd" d="M10 3a1 1 0 011 1v5h5a1 1 0 110 2h-5v5a1 1 0 11-2 0v-5H4a1 1 0 110-2h5V4a1 1 0 011-1z" clip-rule="evenodd" />
        </svg>
      </button>
    </div>
  </div>
</div>

<script>
  import * as THREE from 'three';
  import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';

  // Auto-detect per-face textures based on the found texture file
  function getPerFaceTextureConfig(textureFile: string): { top: string; bottom: string; sides: string } | null {
    // If fuzzy matching found a _top texture, automatically derive side and bottom
    if (textureFile.endsWith('_top.png')) {
      const baseName = textureFile.replace('_top.png', '');
      return {
        top: textureFile,  // Already found by fuzzy matching
        bottom: `${baseName}_bottom.png`,  // Try bottom variant
        sides: `${baseName}_side.png`  // Try side variant
      };
    }

    return null;
  }

  // Texture mapping: simplified name -> texture filename
  const TEXTURE_MAP: Record<string, string> = {
    'stone': 'stone.png',
    'dirt': 'dirt.png',
    'grass': 'grass_block_side.png',
    'grass_block': 'grass_block_side.png',
    'sand': 'sand.png',
    'wood': 'oak_planks.png',
    'planks': 'oak_planks.png',
    'oak_planks': 'oak_planks.png',
    'glass': 'glass.png',
    'white_concrete': 'white_concrete.png',
    'orange_concrete': 'orange_concrete.png',
    'magenta_concrete': 'magenta_concrete.png',
    'light_blue_concrete': 'light_blue_concrete.png',
    'yellow_concrete': 'yellow_concrete.png',
    'lime_concrete': 'lime_concrete.png',
    'pink_concrete': 'pink_concrete.png',
    'gray_concrete': 'gray_concrete.png',
    'light_gray_concrete': 'light_gray_concrete.png',
    'cyan_concrete': 'cyan_concrete.png',
    'purple_concrete': 'purple_concrete.png',
    'blue_concrete': 'blue_concrete.png',
    'brown_concrete': 'brown_concrete.png',
    'green_concrete': 'green_concrete.png',
    'red_concrete': 'red_concrete.png',
    'black_concrete': 'black_concrete.png',
    'white': 'white_concrete.png',
    'orange': 'orange_concrete.png',
    'yellow': 'yellow_concrete.png',
    'lime': 'lime_concrete.png',
    'pink': 'pink_concrete.png',
    'gray': 'gray_concrete.png',
    'cyan': 'cyan_concrete.png',
    'purple': 'purple_concrete.png',
    'blue': 'blue_concrete.png',
    'brown': 'brown_concrete.png',
    'green': 'green_concrete.png',
    'red': 'red_concrete.png',
    'black': 'black_concrete.png',
    'concrete': 'white_concrete.png',
    'wool': 'white_wool.png',
    'white_wool': 'white_wool.png',
    'terracotta': 'terracotta.png',
    'white_terracotta': 'white_terracotta.png',
    'orange_terracotta': 'orange_terracotta.png',
    'yellow_terracotta': 'yellow_terracotta.png',
    'brown_terracotta': 'brown_terracotta.png',
    'red_terracotta': 'red_terracotta.png',
    'light_blue_terracotta': 'light_blue_terracotta.png',
    'iron': 'iron_block.png',
    'iron_block': 'iron_block.png',
    'gold': 'gold_block.png',
    'gold_block': 'gold_block.png',
    'diamond': 'diamond_block.png',
    'diamond_block': 'diamond_block.png',
    'emerald': 'emerald_block.png',
    'emerald_block': 'emerald_block.png',
    'obsidian': 'obsidian.png',
    'bedrock': 'bedrock.png',
    'brick': 'bricks.png',
    'bricks': 'bricks.png',
    'cobblestone': 'cobblestone.png',
    'stone_bricks': 'stone_bricks.png',
    'oak_log': 'oak_log.png',
    'spruce_log': 'spruce_log.png',
    'birch_log': 'birch_log.png',
    'jungle_log': 'jungle_log.png',
    'acacia_log': 'acacia_log.png',
    'dark_oak_log': 'dark_oak_log.png',
    'leaves': 'oak_leaves.png',
    'oak_leaves': 'oak_leaves.png',
    'spruce_leaves': 'spruce_leaves.png',
    'glowstone': 'glowstone.png',
    'sea_lantern': 'sea_lantern.png',
    'quartz': 'quartz_block_side.png',
    'quartz_block': 'quartz_block_side.png',
    'prismarine': 'prismarine.png',
    'netherrack': 'netherrack.png',
    'end_stone': 'end_stone.png',
    'spruce_planks': 'spruce_planks.png',
    'birch_planks': 'birch_planks.png',
    'jungle_planks': 'jungle_planks.png',
    'acacia_planks': 'acacia_planks.png',
    'dark_oak_planks': 'dark_oak_planks.png',
    'light_blue_stained_glass': 'light_blue_stained_glass.png',
    'stained_glass': 'glass.png',
    'water': 'water_still.png',
    'lava': 'lava_still.png',
  };

  // Minecraft color mapping (expanded - kept as fallback)
  const MINECRAFT_COLORS: Record<string, string> = {
    // Basic colors
    white: '#FFFFFF',
    orange: '#F9801D',
    magenta: '#C74EBD',
    light_blue: '#3AB3DA',
    yellow: '#FED83D',
    lime: '#80C71F',
    pink: '#F38BAA',
    gray: '#474F52',
    light_gray: '#9D9D97',
    cyan: '#169C9C',
    purple: '#8932B8',
    blue: '#3C44AA',
    brown: '#825432',
    green: '#5E7C16',
    red: '#B02E26',
    black: '#1D1D21',
    // Wood
    oak_planks: '#9C7F4E',
    spruce_planks: '#694F33',
    birch_planks: '#D7CB8D',
    jungle_planks: '#9F6C4B',
    acacia_planks: '#BA6337',
    dark_oak_planks: '#4C2F1A',
    bamboo_planks: '#C8B479',
    oak_log: '#766F4C',
    spruce_log: '#554937',
    birch_log: '#DFE0DF',
    stripped_oak_log: '#B19762',
    // Stone
    stone: '#7F7F7F',
    cobblestone: '#7F7F7F',
    stone_bricks: '#7B7B7B',
    smooth_stone: '#9E9E9E',
    andesite: '#8C8C8C',
    diorite: '#C5C5C5',
    granite: '#9A6C61',
    mossy_cobblestone: '#6A7F5F',
    cracked_stone_bricks: '#737373',
    chiseled_stone_bricks: '#757575',
    deepslate: '#4F4F4F',
    // Metals
    iron_block: '#D8D8D8',
    gold_block: '#FDD835',
    diamond_block: '#5CE3E3',
    emerald_block: '#4EFF4E',
    netherite_block: '#2E2E2E',
    copper_block: '#B77A57',
    exposed_copper: '#A3785F',
    weathered_copper: '#6D9F8B',
    oxidized_copper: '#51887A',
    // Glass
    glass: '#C0F0FF',
    tinted_glass: '#3F3844',
    white_stained_glass: '#F0F0F0',
    black_stained_glass: '#1A1A1A',
    // Natural
    grass_block: '#7CB342',
    dirt: '#8B5D33',
    coarse_dirt: '#7A5033',
    sand: '#DCC89C',
    red_sand: '#C0674A',
    gravel: '#857E7E',
    clay: '#A1A8B3',
    moss_block: '#5C7F4E',
    snow_block: '#FAFEFF',
    ice: '#B3D5F0',
    packed_ice: '#98CBE9',
    blue_ice: '#749FE3',
    // Nether
    netherrack: '#683131',
    soul_sand: '#524133',
    soul_soil: '#4A3B30',
    crimson_planks: '#70394B',
    warped_planks: '#3A6365',
    nether_bricks: '#2B1416',
    red_nether_bricks: '#440707',
    blackstone: '#2A2123',
    basalt: '#4C4D51',
    // Plants
    oak_leaves: '#59A337',
    spruce_leaves: '#3E5F27',
    azalea_leaves: '#629755',
    flowering_azalea_leaves: '#629755',
    // Special
    obsidian: '#0F0820',
    crying_obsidian: '#21134F',
    quartz_block: '#EEEDE4',
    purpur_block: '#A67BA6',
    prismarine: '#4E927F',
    dark_prismarine: '#36605A',
    sea_lantern: '#B4D8DC',
    glowstone: '#FFEEAA',
    redstone_block: '#A81F10',
    bone_block: '#E4DFD1',
    end_stone: '#DFE6BB',
    end_stone_bricks: '#DFE6B0',
    honeycomb_block: '#E68B2D',
    amethyst_block: '#8B5EAF',
    // Bright
    shroomlight: '#FF9C41',
    jack_o_lantern: '#E89100',
    redstone_lamp: '#FFC777',
    // Default
    default: '#888888',
  };

  function extractColorFromBlock(voxel: any): string {
    // First, check if the AI provided a color hex code
    if (voxel.color) {
      return voxel.color;
    }

    // Fallback: Extract color from minecraft:color_material format
    const blockName = voxel.block;
    const parts = blockName.replace('minecraft:', '').split('_');

    // Try to find color in block name
    for (const part of parts) {
      if (MINECRAFT_COLORS[part]) {
        return MINECRAFT_COLORS[part];
      }
    }

    // Try full block name (for oak_planks, stone, etc.)
    if (MINECRAFT_COLORS[blockName.replace('minecraft:', '')]) {
      return MINECRAFT_COLORS[blockName.replace('minecraft:', '')];
    }

    return MINECRAFT_COLORS.default;
  }

  // Make viewer globally accessible
  (window as any).VoxelViewer = class VoxelViewer {
    scene: THREE.Scene;
    camera: THREE.PerspectiveCamera;
    renderer: THREE.WebGLRenderer;
    container: HTMLElement;
    animationId: number | null = null;
    voxelGroup: THREE.Group;
    voxelData: any[] = [];
    originalVoxelData: any[] = [];
    components: any[] = [];
    componentBlockRanges: Map<string, { start: number; end: number }> = new Map();
    componentTransforms: Map<string, { rotation: { x: number; y: number; z: number }; position: { x: number; y: number; z: number } }> = new Map();
    selectedComponents: Set<string> = new Set();
    highlightBoxes: THREE.LineSegments[] = [];
    hiddenComponents: Set<string> = new Set();
    controls: any;
    currentScale: number = 1.0;
    history: Array<{ voxelData: any[]; components: any[]; componentBlockRanges: Map<string, { start: number; end: number }> }> = [];
    historyIndex: number = -1;
    maxHistorySize: number = 50;
    raycaster: THREE.Raycaster;
    mouse: THREE.Vector2;
    hoveredComponent: string | null = null;
    tooltip: HTMLDivElement;
    textureLoader: THREE.TextureLoader;
    textureCache: Map<string, THREE.Texture> = new Map();

    // View compass/gizmo
    compassScene: THREE.Scene;
    compassCamera: THREE.OrthographicCamera;
    compassRenderer: THREE.WebGLRenderer;
    compassSize: number = 128;
    isAnimatingCamera: boolean = false;

    constructor(containerId: string) {
      const container = document.getElementById(containerId);
      if (!container) {
        throw new Error(`Container ${containerId} not found`);
      }
      this.container = container;

      // Scene setup
      this.scene = new THREE.Scene();
      this.scene.background = new THREE.Color(0xf8fafc);

      // Camera setup
      const width = container.clientWidth;
      const height = container.clientHeight;
      this.camera = new THREE.PerspectiveCamera(60, width / height, 0.1, 1000);
      this.camera.position.set(20, 15, 20);
      this.camera.lookAt(0, 0, 0);

      // Renderer setup
      this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      this.renderer.setSize(width, height);
      this.renderer.shadowMap.enabled = true;
      this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      container.appendChild(this.renderer.domElement);

      // Lights
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      this.scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(10, 20, 10);
      directionalLight.castShadow = true;
      directionalLight.shadow.camera.left = -20;
      directionalLight.shadow.camera.right = 20;
      directionalLight.shadow.camera.top = 20;
      directionalLight.shadow.camera.bottom = -20;
      this.scene.add(directionalLight);

      // Voxel group
      this.voxelGroup = new THREE.Group();
      this.scene.add(this.voxelGroup);

      // Raycaster for mouse interaction
      this.raycaster = new THREE.Raycaster();
      this.mouse = new THREE.Vector2();

      // Texture loader
      this.textureLoader = new THREE.TextureLoader();

      // Create tooltip element
      this.tooltip = document.createElement('div');
      this.tooltip.style.position = 'absolute';
      this.tooltip.style.padding = '6px 10px';
      this.tooltip.style.background = 'rgba(0, 0, 0, 0.8)';
      this.tooltip.style.color = 'white';
      this.tooltip.style.borderRadius = '4px';
      this.tooltip.style.fontSize = '12px';
      this.tooltip.style.pointerEvents = 'none';
      this.tooltip.style.display = 'none';
      this.tooltip.style.zIndex = '1000';
      this.tooltip.style.fontFamily = 'monospace';
      document.body.appendChild(this.tooltip);

      // Mouse controls
      this.setupMouseControls();

      // Initialize view compass
      this.compassScene = new THREE.Scene();
      this.compassCamera = new THREE.OrthographicCamera(-2, 2, 2, -2, 0.1, 100);
      this.compassCamera.position.set(0, 0, 10);

      this.compassRenderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: true
      });
      this.compassRenderer.setSize(this.compassSize, this.compassSize);
      this.compassRenderer.domElement.style.position = 'absolute';
      this.compassRenderer.domElement.style.top = '10px';
      this.compassRenderer.domElement.style.right = '10px';
      this.compassRenderer.domElement.style.cursor = 'pointer';
      this.compassRenderer.domElement.style.borderRadius = '8px';
      this.compassRenderer.domElement.style.border = '2px solid rgba(255, 255, 255, 0.3)';
      this.compassRenderer.domElement.style.boxShadow = '0 4px 6px rgba(0, 0, 0, 0.1)';
      container.appendChild(this.compassRenderer.domElement);

      this.initCompass();
      this.setupCompassClickHandling();

      // Handle window resize
      window.addEventListener('resize', () => this.onWindowResize());

      // Setup camera control buttons
      this.setupCameraControls(containerId);

      // Start animation loop
      this.animate();
    }

    setupMouseControls() {
      // Use OrbitControls for smooth, intuitive rotation
      this.controls = new OrbitControls(this.camera, this.renderer.domElement);

      // Configure controls for better feel
      this.controls.enableDamping = true; // Smooth inertia
      this.controls.dampingFactor = 0.05;
      this.controls.rotateSpeed = 0.8;
      this.controls.zoomSpeed = 1.2;
      this.controls.panSpeed = 0.8;

      // Set zoom limits (allow very close zoom for interior inspection)
      this.controls.minDistance = 0.5;
      this.controls.maxDistance = 500;  // Allow zooming out far for large models

      // Enable right-click to pan
      this.controls.mouseButtons = {
        LEFT: THREE.MOUSE.ROTATE,
        MIDDLE: THREE.MOUSE.DOLLY,
        RIGHT: THREE.MOUSE.PAN
      };

      // Mouse move for hover tooltip
      this.renderer.domElement.addEventListener('mousemove', (event) => this.onMouseMove(event));
    }

    setupCameraControls(containerId: string) {
      const focusBtn = document.getElementById(`${containerId}-focus-btn`);
      const zoomInBtn = document.getElementById(`${containerId}-zoom-in-btn`);
      const zoomOutBtn = document.getElementById(`${containerId}-zoom-out-btn`);

      if (focusBtn) {
        focusBtn.addEventListener('click', () => this.focusOnModel());
      }

      if (zoomInBtn) {
        zoomInBtn.addEventListener('click', () => this.zoomIn());
      }

      if (zoomOutBtn) {
        zoomOutBtn.addEventListener('click', () => this.zoomOut());
      }

      // Keyboard shortcuts
      document.addEventListener('keydown', (e) => {
        if (e.key === 'f' || e.key === 'F') {
          this.focusOnModel();
        } else if (e.key === '+' || e.key === '=') {
          this.zoomIn();
        } else if (e.key === '-' || e.key === '_') {
          this.zoomOut();
        }
      });
    }

    zoomIn() {
      if (!this.controls) return;
      const zoomFactor = 0.8;
      const currentDistance = this.camera.position.distanceTo(this.controls.target);
      const newDistance = Math.max(currentDistance * zoomFactor, this.controls.minDistance);
      const direction = new THREE.Vector3().subVectors(this.camera.position, this.controls.target).normalize();
      this.camera.position.copy(this.controls.target).add(direction.multiplyScalar(newDistance));
      this.controls.update();
    }

    zoomOut() {
      if (!this.controls) return;
      const zoomFactor = 1.25;
      const currentDistance = this.camera.position.distanceTo(this.controls.target);
      const newDistance = Math.min(currentDistance * zoomFactor, this.controls.maxDistance);
      const direction = new THREE.Vector3().subVectors(this.camera.position, this.controls.target).normalize();
      this.camera.position.copy(this.controls.target).add(direction.multiplyScalar(newDistance));
      this.controls.update();
    }

    focusOnModel() {
      if (!this.voxelGroup || this.voxelGroup.children.length === 0) return;

      // Calculate bounding box of all visible voxels
      const box = new THREE.Box3();
      this.voxelGroup.children.forEach((child) => {
        if (child.visible) {
          box.expandByObject(child);
        }
      });

      if (box.isEmpty()) return;

      // Get center and size of the bounding box
      const center = box.getCenter(new THREE.Vector3());
      const size = box.getSize(new THREE.Vector3());
      const maxDim = Math.max(size.x, size.y, size.z);

      // Calculate camera distance to fit the model
      const fov = this.camera.fov * (Math.PI / 180);
      const distance = Math.abs(maxDim / Math.tan(fov / 2)) * 1.5;

      // Set camera position
      const direction = new THREE.Vector3().subVectors(this.camera.position, this.controls.target).normalize();
      this.camera.position.copy(center).add(direction.multiplyScalar(distance));

      // Update controls target
      this.controls.target.copy(center);
      this.controls.update();
    }

    initCompass() {
      // Create axes group
      const axesGroup = new THREE.Group();

      // X axis (red) - pointing right
      const xGeometry = new THREE.CylinderGeometry(0.05, 0.05, 1.5, 8);
      const xMaterial = new THREE.MeshBasicMaterial({ color: 0xef4444 });
      const xAxis = new THREE.Mesh(xGeometry, xMaterial);
      xAxis.rotation.z = -Math.PI / 2;
      xAxis.position.x = 0.75;

      // X cone (arrow tip)
      const xCone = new THREE.Mesh(
        new THREE.ConeGeometry(0.1, 0.3, 8),
        xMaterial
      );
      xCone.rotation.z = -Math.PI / 2;
      xCone.position.x = 1.65;

      // Y axis (green) - pointing up
      const yGeometry = new THREE.CylinderGeometry(0.05, 0.05, 1.5, 8);
      const yMaterial = new THREE.MeshBasicMaterial({ color: 0x22c55e });
      const yAxis = new THREE.Mesh(yGeometry, yMaterial);
      yAxis.position.y = 0.75;

      // Y cone
      const yCone = new THREE.Mesh(
        new THREE.ConeGeometry(0.1, 0.3, 8),
        yMaterial
      );
      yCone.position.y = 1.65;

      // Z axis (blue) - pointing forward
      const zGeometry = new THREE.CylinderGeometry(0.05, 0.05, 1.5, 8);
      const zMaterial = new THREE.MeshBasicMaterial({ color: 0x3b82f6 });
      const zAxis = new THREE.Mesh(zGeometry, zMaterial);
      zAxis.rotation.x = Math.PI / 2;
      zAxis.position.z = 0.75;

      // Z cone
      const zCone = new THREE.Mesh(
        new THREE.ConeGeometry(0.1, 0.3, 8),
        zMaterial
      );
      zCone.rotation.x = -Math.PI / 2;
      zCone.position.z = 1.65;

      axesGroup.add(xAxis, xCone, yAxis, yCone, zAxis, zCone);

      // Add text labels for axes
      const createTextSprite = (text: string, color: string) => {
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d')!;
        canvas.width = 128;
        canvas.height = 128;

        context.fillStyle = color;
        context.font = 'Bold 80px Arial';
        context.textAlign = 'center';
        context.textBaseline = 'middle';
        context.fillText(text, 64, 64);

        const texture = new THREE.CanvasTexture(canvas);
        const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
        const sprite = new THREE.Sprite(material);
        sprite.scale.set(0.5, 0.5, 1);
        return sprite;
      };

      const xLabel = createTextSprite('X', '#ef4444');
      xLabel.position.set(2.0, 0, 0);
      axesGroup.add(xLabel);

      const yLabel = createTextSprite('Y', '#22c55e');
      yLabel.position.set(0, 2.0, 0);
      axesGroup.add(yLabel);

      const zLabel = createTextSprite('Z', '#3b82f6');
      zLabel.position.set(0, 0, 2.0);
      axesGroup.add(zLabel);

      // Add a subtle sphere at center
      const centerSphere = new THREE.Mesh(
        new THREE.SphereGeometry(0.15, 16, 16),
        new THREE.MeshBasicMaterial({ color: 0xcccccc })
      );
      axesGroup.add(centerSphere);

      this.compassScene.add(axesGroup);
    }

    setupCompassClickHandling() {
      const views = {
        front: { position: [0, 0, 1], target: [0, 0, 0] },
        back: { position: [0, 0, -1], target: [0, 0, 0] },
        left: { position: [-1, 0, 0], target: [0, 0, 0] },
        right: { position: [1, 0, 0], target: [0, 0, 0] },
        top: { position: [0, 1, 0], target: [0, 0, 0] },
        bottom: { position: [0, -1, 0], target: [0, 0, 0] }
      };

      this.compassRenderer.domElement.addEventListener('click', (event) => {
        const rect = this.compassRenderer.domElement.getBoundingClientRect();
        const x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        const y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

        // Determine which face was clicked based on position
        let selectedView: keyof typeof views | null = null;

        if (Math.abs(x) > Math.abs(y)) {
          selectedView = x > 0 ? 'right' : 'left';
        } else {
          selectedView = y > 0 ? 'top' : 'bottom';
        }

        // Check if click is more towards front/back (based on distance from center)
        const distFromCenter = Math.sqrt(x * x + y * y);
        if (distFromCenter < 0.5) {
          // If clicking near center, determine front/back based on subtle differences
          if (Math.abs(x) < 0.3 && Math.abs(y) < 0.3) {
            selectedView = 'front'; // Default to front when clicking center
          }
        }

        if (selectedView) {
          this.snapToView(selectedView, views[selectedView]);
        }
      });
    }

    snapToView(viewName: string, view: { position: number[], target: number[] }) {
      if (this.isAnimatingCamera) return;

      this.isAnimatingCamera = true;

      // Get current target
      const currentTarget = this.controls.target.clone();
      const targetPos = new THREE.Vector3(view.target[0], view.target[1], view.target[2]);

      // Calculate distance to maintain
      const currentDistance = this.camera.position.distanceTo(currentTarget);

      // Calculate new position
      const direction = new THREE.Vector3(view.position[0], view.position[1], view.position[2]);
      const newPosition = targetPos.clone().add(direction.multiplyScalar(currentDistance));

      // Animate camera
      const startPosition = this.camera.position.clone();
      const startTime = performance.now();
      const duration = 500; // ms

      const animateCamera = () => {
        const elapsed = performance.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);

        // Ease-out cubic
        const eased = 1 - Math.pow(1 - progress, 3);

        this.camera.position.lerpVectors(startPosition, newPosition, eased);
        this.camera.lookAt(targetPos);
        this.controls.target.copy(targetPos);
        this.controls.update();

        if (progress < 1) {
          requestAnimationFrame(animateCamera);
        } else {
          this.isAnimatingCamera = false;
        }
      };

      animateCamera();
    }

    loadVoxels(voxelData: Array<{ block: string; x: number; y: number; z: number; scale: number[] }>, components?: any[], placementMode: string = 'display') {
      // Store original data and working copy
      this.originalVoxelData = JSON.parse(JSON.stringify(voxelData)); // Deep copy
      this.voxelData = voxelData;
      this.components = components || [];
      this.selectedComponents.clear();
      this.currentScale = 1.0;

      // Apply placement mode transformations
      if (placementMode === 'blocks') {
        // Real Blocks mode: Scale up and snap to integer grid
        this.convertToRealBlocks();
      }
      // Display mode: Keep fractional coordinates as-is

      // Extract component block ranges from component metadata
      this.componentBlockRanges.clear();
      let currentIndex = 0;

      this.components.forEach(comp => {
        if (comp.blockRange) {
          // Use provided block range from AI
          this.componentBlockRanges.set(comp.id, {
            start: comp.blockRange.start,
            end: comp.blockRange.end
          });
        } else if (comp.blocks && Array.isArray(comp.blocks)) {
          // Calculate block range from blocks array (for user-created components)
          const blockCount = comp.blocks.length;
          if (blockCount > 0) {
            this.componentBlockRanges.set(comp.id, {
              start: currentIndex,
              end: currentIndex + blockCount - 1
            });
            currentIndex += blockCount;
          }
        }
      });

      // Initialize history with initial state
      this.history = [];
      this.historyIndex = -1;
      this.saveState();

      this.renderVoxels();
    }

    convertToRealBlocks() {
      // Convert fractional voxel coordinates to integer grid for Minecraft real blocks
      // This mirrors the logic from deploy_java_api.py lines 671-740
      const startTime = performance.now();

      const seen = new Set<string>();
      const convertedBlocks: any[] = [];

      for (const block of this.voxelData) {
        // Get block scale (default 0.22 for AI models)
        const blockScale = block.scale ? block.scale[0] : 0.22;

        // Calculate upscale factor to preserve detail
        const upscaleFactor = 1.0 / blockScale;

        // Scale up coordinates
        let x = block.x * upscaleFactor;
        let y = block.y * upscaleFactor;
        let z = block.z * upscaleFactor;

        // Round to integers for Minecraft grid
        const bx = Math.round(x);
        const by = Math.round(y);
        const bz = Math.round(z);

        // Create unique position key
        const key = `${bx},${by},${bz}`;

        // Skip if we already have a block at this position
        if (!seen.has(key)) {
          seen.add(key);
          convertedBlocks.push({
            ...block,
            x: bx,
            y: by,
            z: bz,
            // In real blocks mode, each block is 1x1x1 (full Minecraft block size)
            scale: [1, 1, 1]
          });
        }
      }

      // Update voxelData with converted blocks
      const originalCount = this.voxelData.length;
      // For large arrays, avoid spread operator which causes stack overflow
      // Use direct assignment instead
      this.voxelData = convertedBlocks;

      const endTime = performance.now();
      console.log(`[RealBlocks] Conversion took ${(endTime - startTime).toFixed(2)}ms. Scaled up and snapped to grid. ${convertedBlocks.length} blocks (removed ${originalCount - convertedBlocks.length} duplicates)`);
    }

    setPlacementMode(mode: string) {
      console.log(`[PlacementMode] START - Switching to ${mode} mode (${this.originalVoxelData.length} blocks)`);
      const startTime = performance.now();

      // Just copy the data
      console.log(`[PlacementMode] Copying voxel data...`);
      this.voxelData = this.originalVoxelData.slice();
      console.log(`[PlacementMode] Copy done, took ${(performance.now() - startTime).toFixed(2)}ms`);

      if (mode === 'blocks') {
        console.log(`[PlacementMode] Converting to real blocks...`);
        this.convertToRealBlocks();
        console.log(`[PlacementMode] Conversion done, took ${(performance.now() - startTime).toFixed(2)}ms`);
      }

      // Re-render
      console.log(`[PlacementMode] Rendering...`);
      this.renderVoxels();

      const endTime = performance.now();
      console.log(`[PlacementMode] COMPLETE - Total took ${(endTime - startTime).toFixed(2)}ms. Now ${this.voxelData.length} blocks`);
    }

    findBestTextureMatch(blockName: string): string {
      // Clean up block name first
      let cleanName = blockName.replace('minecraft:', '');

      // Fix various AI duplication patterns
      const parts = cleanName.split('_');

      // Pattern 1: Exact half duplication
      const halfLen = Math.floor(parts.length / 2);
      if (parts.length > 1 && parts.length % 2 === 0) {
        const firstHalf = parts.slice(0, halfLen).join('_');
        const secondHalf = parts.slice(halfLen).join('_');
        if (firstHalf === secondHalf) {
          cleanName = firstHalf;
        }
      }

      // Pattern 2: Adjacent duplicates
      const deduped: string[] = [];
      for (let i = 0; i < parts.length; i++) {
        if (i === 0 || parts[i] !== parts[i - 1]) {
          deduped.push(parts[i]);
        }
      }
      if (deduped.length < parts.length) {
        cleanName = deduped.join('_');
      }

      // Pattern 3: First and last part same
      const dedupedParts = cleanName.split('_');
      if (dedupedParts.length >= 3 && dedupedParts[0] === dedupedParts[dedupedParts.length - 1]) {
        cleanName = dedupedParts.slice(1).join('_');
      }

      // Try exact mapping first (fastest)
      if (TEXTURE_MAP[cleanName]) {
        return TEXTURE_MAP[cleanName];
      }

      // Try with .png extension
      const withPng = `${cleanName}.png`;
      if (TEXTURE_MAP[withPng]) {
        return TEXTURE_MAP[withPng];
      }

      // Fuzzy matching - find best match from available textures
      // Common patterns for specific blocks
      const specialCases: Record<string, string> = {
        'lava': 'lava_still.png',
        'water': 'water_still.png',
        'grass': 'grass_block_side.png',
      };

      if (specialCases[cleanName]) {
        console.log(`[VoxelViewer] Fuzzy match: "${blockName}" -> "${specialCases[cleanName]}"`);
        return specialCases[cleanName];
      }

      // Handle doors (they have _bottom and _top textures, use bottom for voxels)
      if (cleanName.endsWith('_door')) {
        const doorTexture = `${cleanName}_bottom.png`;
        console.log(`[VoxelViewer] Door texture: "${blockName}" -> "${doorTexture}"`);
        return doorTexture;
      }

      // Default: try the clean name as filename
      console.log(`[VoxelViewer] Using direct match: "${blockName}" -> "${cleanName}.png"`);
      return `${cleanName}.png`;
    }

    getTexture(blockName: string): THREE.Texture {
      // Check cache first
      if (this.textureCache.has(blockName)) {
        return this.textureCache.get(blockName)!;
      }

      const textureFile = this.findBestTextureMatch(blockName);
      const texturePath = `/textures/block/${textureFile}`;

      // Load texture with error handling and smart fallbacks
      const texture = this.textureLoader.load(
        texturePath,
        () => {
          // Success - texture loaded
        },
        undefined,
        (error) => {
          // Error - texture not found, try smart fallbacks
          let fallbackPath: string | null = null;

          // Extract block ID from "minecraft:block_name" format
          const blockId = blockName.replace('minecraft:', '');

          // Smart fallback for slabs: try base block texture
          if (blockId.endsWith('_slab')) {
            const baseBlock = blockId.replace('_slab', '');
            // Special cases
            if (baseBlock === 'smooth_stone') {
              fallbackPath = '/textures/block/smooth_stone.png';
            } else if (baseBlock === 'spruce') {
              fallbackPath = '/textures/block/spruce_planks.png';
            } else if (baseBlock === 'stone_brick') {
              fallbackPath = '/textures/block/stone_bricks.png';
            } else {
              // Generic: try base block name or base_planks
              fallbackPath = `/textures/block/${baseBlock}.png`;
            }
          }
          // Smart fallback for smooth_ variants: try the base block
          else if (blockId.startsWith('smooth_')) {
            const baseBlock = blockId.replace('smooth_', '');
            // Special cases
            if (baseBlock === 'quartz') {
              fallbackPath = '/textures/block/quartz_block_side.png';
            } else if (baseBlock === 'stone') {
              fallbackPath = '/textures/block/smooth_stone.png';
            } else {
              // Generic: try base_block_side.png
              fallbackPath = `/textures/block/${baseBlock}_block_side.png`;
            }
          }
          // Smart fallback for doors: try _bottom variant, then planks
          else if (blockId.endsWith('_door')) {
            const woodType = blockId.replace('_door', '');
            fallbackPath = `/textures/block/${woodType}_door_bottom.png`;
            // If bottom doesn't exist, will try planks in secondary fallback
          }
          // Smart fallback for carpets: use corresponding wool texture
          else if (blockId.endsWith('_carpet')) {
            const color = blockId.replace('_carpet', '');
            fallbackPath = `/textures/block/${color}_wool.png`;
          }
          // Smart fallback for fences: use corresponding planks texture
          else if (blockId.endsWith('_fence')) {
            const woodType = blockId.replace('_fence', '');
            fallbackPath = `/textures/block/${woodType}_planks.png`;
          }
          // Smart fallback for stairs: use corresponding planks/base texture
          else if (blockId.endsWith('_stairs')) {
            const baseType = blockId.replace('_stairs', '');
            // Wood stairs use planks, stone stairs use the base block
            if (baseType.includes('oak') || baseType === 'spruce' || baseType === 'birch' ||
                baseType === 'jungle' || baseType === 'acacia' || baseType === 'dark_oak' ||
                baseType === 'crimson' || baseType === 'warped' || baseType === 'bamboo') {
              fallbackPath = `/textures/block/${baseType}_planks.png`;
            } else {
              fallbackPath = `/textures/block/${baseType}.png`;
            }
          }

          // Special case: bamboo_planks doesn't exist, use bamboo_stalk
          if (blockId === 'bamboo_planks') {
            fallbackPath = '/textures/block/bamboo_stalk.png';
          }

          // Try fallback path if we have one
          if (fallbackPath) {
            console.warn(`[VoxelViewer] Texture not found for "${blockName}": ${texturePath}, trying fallback: ${fallbackPath}`);
            const fallbackTexture = this.textureLoader.load(
              fallbackPath,
              () => {
                // Fallback succeeded
                fallbackTexture.magFilter = THREE.NearestFilter;
                fallbackTexture.minFilter = THREE.NearestFilter;
                this.textureCache.set(blockName, fallbackTexture);
              },
              undefined,
              () => {
                // Fallback also failed, use stone
                console.warn(`[VoxelViewer] Fallback also failed, defaulting to stone.png`);
                const stonePath = '/textures/block/stone.png';
                const stoneTexture = this.textureLoader.load(stonePath);
                stoneTexture.magFilter = THREE.NearestFilter;
                stoneTexture.minFilter = THREE.NearestFilter;
                this.textureCache.set(blockName, stoneTexture);
              }
            );
          } else {
            // No fallback available, use stone
            console.warn(`[VoxelViewer] Texture not found for "${blockName}": ${texturePath}, defaulting to stone.png`);
            const stonePath = '/textures/block/stone.png';
            const stoneTexture = this.textureLoader.load(stonePath);
            stoneTexture.magFilter = THREE.NearestFilter;
            stoneTexture.minFilter = THREE.NearestFilter;
            this.textureCache.set(blockName, stoneTexture);
          }
        }
      );

      // Pixelated filtering (like Minecraft)
      texture.magFilter = THREE.NearestFilter;
      texture.minFilter = THREE.NearestFilter;

      this.textureCache.set(blockName, texture);
      return texture;
    }

    getMaterials(blockType: string, isGlass: boolean, isDimmed: boolean, isGlowing: boolean): THREE.Material | THREE.Material[] {
      const baseOpacity = isGlass ? 0.6 : 1.0;
      const opacity = isDimmed ? baseOpacity * 0.2 : baseOpacity;  // Increased from 0.08 to 0.2 for better visibility

      // First, use fuzzy matching to find the best texture
      const textureFile = this.findBestTextureMatch(blockType);

      // Check if this texture has per-face variants (e.g., ends with _top.png)
      const perFaceConfig = getPerFaceTextureConfig(textureFile);

      if (perFaceConfig) {
        // Load textures for each face
        const loadTex = (filename: string) => {
          const path = `/textures/block/${filename}`;
          const tex = this.textureLoader.load(path);
          tex.magFilter = THREE.NearestFilter;
          tex.minFilter = THREE.NearestFilter;
          return tex;
        };

        const top = loadTex(perFaceConfig.top);
        const bottom = loadTex(perFaceConfig.bottom);
        const sides = loadTex(perFaceConfig.sides);

        // Create materials for each face: [right, left, top, bottom, front, back]
        const createMat = (texture: THREE.Texture) => new THREE.MeshLambertMaterial({
          map: texture,
          transparent: isGlass || isDimmed,
          opacity: opacity,
          side: THREE.DoubleSide,
          emissive: isGlowing ? 0xffffff : 0x000000,
          emissiveIntensity: isGlowing ? 0.3 : 0,
        });

        return [
          createMat(sides),  // right (+X)
          createMat(sides),  // left (-X)
          createMat(top),    // top (+Y)
          createMat(bottom), // bottom (-Y)
          createMat(sides),  // front (+Z)
          createMat(sides),  // back (-Z)
        ];
      } else {
        // Single texture for all faces
        const texture = this.getTexture(blockType);
        return new THREE.MeshLambertMaterial({
          map: texture,
          transparent: isGlass || isDimmed,
          opacity: opacity,
          side: THREE.DoubleSide,
          emissive: isGlowing ? 0xffffff : 0x000000,
          emissiveIntensity: isGlowing ? 0.3 : 0,
        });
      }
    }

    saveState() {
      // Remove any future history if we're not at the end
      if (this.historyIndex < this.history.length - 1) {
        this.history = this.history.slice(0, this.historyIndex + 1);
      }

      // Save current state
      const state = {
        voxelData: JSON.parse(JSON.stringify(this.voxelData)),
        components: JSON.parse(JSON.stringify(this.components)),
        componentBlockRanges: new Map(this.componentBlockRanges)
      };

      this.history.push(state);

      // Limit history size
      if (this.history.length > this.maxHistorySize) {
        this.history.shift();
      } else {
        this.historyIndex++;
      }

      // Update undo/redo button states
      this.updateUndoRedoButtons();
    }

    undo() {
      if (this.historyIndex > 0) {
        this.historyIndex--;
        this.restoreState(this.history[this.historyIndex]);
        this.updateUndoRedoButtons();
      }
    }

    redo() {
      if (this.historyIndex < this.history.length - 1) {
        this.historyIndex++;
        this.restoreState(this.history[this.historyIndex]);
        this.updateUndoRedoButtons();
      }
    }

    restoreState(state: any) {
      this.voxelData = JSON.parse(JSON.stringify(state.voxelData));
      this.components = JSON.parse(JSON.stringify(state.components));
      this.componentBlockRanges = new Map(state.componentBlockRanges);
      this.renderVoxels();
    }

    updateUndoRedoButtons() {
      const undoBtn = document.getElementById('undo-btn');
      const redoBtn = document.getElementById('redo-btn');

      if (undoBtn) {
        undoBtn.classList.toggle('opacity-50', this.historyIndex <= 0);
        undoBtn.classList.toggle('cursor-not-allowed', this.historyIndex <= 0);
        (undoBtn as HTMLButtonElement).disabled = this.historyIndex <= 0;
      }

      if (redoBtn) {
        redoBtn.classList.toggle('opacity-50', this.historyIndex >= this.history.length - 1);
        redoBtn.classList.toggle('cursor-not-allowed', this.historyIndex >= this.history.length - 1);
        (redoBtn as HTMLButtonElement).disabled = this.historyIndex >= this.history.length - 1;
      }
    }

    renderVoxels() {
      // Clear existing voxels and highlight boxes
      while (this.voxelGroup.children.length > 0) {
        this.voxelGroup.remove(this.voxelGroup.children[0]);
      }
      // Remove all existing highlight boxes
      this.highlightBoxes.forEach(box => {
        this.scene.remove(box);
      });
      this.highlightBoxes = [];

      if (!this.voxelData || this.voxelData.length === 0) {
        console.warn('No voxel data to load');
        return;
      }

      const voxelData = this.voxelData;

      // Calculate center for better positioning
      let sumX = 0, sumY = 0, sumZ = 0;
      voxelData.forEach(voxel => {
        sumX += voxel.x;
        sumY += voxel.y;
        sumZ += voxel.z;
      });
      const centerX = sumX / voxelData.length;
      const centerY = sumY / voxelData.length;
      const centerZ = sumZ / voxelData.length;

      // Determine which blocks are in selected components (per component)
      let selectedBlockIndices = new Set<number>();
      let selectedBlocksByComponent = new Map<string, Array<{ x: number; y: number; z: number }>>();

      this.selectedComponents.forEach(componentId => {
        if (this.componentBlockRanges.has(componentId)) {
          const componentBlocks: Array<{ x: number; y: number; z: number }> = [];
          const range = this.componentBlockRanges.get(componentId)!;
          for (let i = range.start; i <= range.end; i++) {
            selectedBlockIndices.add(i);
            if (i < voxelData.length) {
              componentBlocks.push({
                x: voxelData[i].x - centerX,
                y: voxelData[i].y - centerY,
                z: voxelData[i].z - centerZ
              });
            }
          }
          selectedBlocksByComponent.set(componentId, componentBlocks);
        }
      });

      // Only apply dimming if we actually have selected blocks
      // This prevents all blocks from being dimmed when selectedComponents has invalid entries
      const hasValidSelection = selectedBlockIndices.size > 0;

      // Debug logging for transparency issues
      if (this.selectedComponents.size > 0 && selectedBlockIndices.size === 0) {
        console.warn('[VoxelViewer] Component selection exists but no blocks matched. This could cause transparency issues.');
        console.warn('[VoxelViewer] Selected component IDs:', Array.from(this.selectedComponents));
        console.warn('[VoxelViewer] Available component ranges:', Array.from(this.componentBlockRanges.keys()));
      }

      // Group blocks by type (for texture-based rendering)
      const blockGroups = new Map<string, { blockType: string; isGlass: boolean; isGlowing: boolean; isDimmed: boolean; blocks: Array<{ x: number; y: number; z: number; scale: number[] }> }>();

      voxelData.forEach((voxel, index) => {
        const isInSelectedComponent = selectedBlockIndices.has(index);

        // Check if this block belongs to a hidden component
        let isHidden = false;
        for (const [compId, range] of this.componentBlockRanges.entries()) {
          if (index >= range.start && index <= range.end) {
            if (this.hiddenComponents.has(compId)) {
              isHidden = true;
              break;
            }
          }
        }

        // Skip hidden blocks
        if (isHidden) {
          return;
        }

        const blockType = voxel.block || 'stone';
        const isGlass = voxel.block.includes('glass') || voxel.block.includes('ice');

        // Only make blocks glow if they're actually light-emitting blocks, not just because add_glow() added brightness
        const lightEmittingBlocks = ['glowstone', 'sea_lantern', 'lantern', 'torch', 'redstone_lamp', 'shroomlight', 'jack_o_lantern', 'campfire'];
        const isGlowing = lightEmittingBlocks.some(light => voxel.block.includes(light));

        // Dim if we have a VALID selection AND this block is NOT in the selected components
        const isDimmed = hasValidSelection && !isInSelectedComponent;
        const key = `${blockType}_${isGlowing}_${isDimmed}`;

        if (!blockGroups.has(key)) {
          blockGroups.set(key, { blockType, isGlass, isGlowing, isDimmed, blocks: [] });
        }
        blockGroups.get(key)!.blocks.push({
          x: voxel.x - centerX,
          y: voxel.y - centerY,
          z: voxel.z - centerZ,
          scale: voxel.scale || [1, 1, 1]
        });
      });

      // Create instanced meshes for each block type
      blockGroups.forEach((group) => {
        const geometry = new THREE.BoxGeometry(1, 1, 1);

        // Get materials (either single or per-face array)
        const materials = this.getMaterials(group.blockType, group.isGlass, group.isDimmed, group.isGlowing);

        const instancedMesh = new THREE.InstancedMesh(geometry, materials, group.blocks.length);
        instancedMesh.castShadow = !group.isGlass; // Glass doesn't cast shadows
        instancedMesh.receiveShadow = true;

        const matrix = new THREE.Matrix4();
        const position = new THREE.Vector3();
        const rotation = new THREE.Quaternion();
        const scale = new THREE.Vector3();

        group.blocks.forEach((block, i) => {
          position.set(block.x, block.y, block.z);
          rotation.set(0, 0, 0, 1);
          scale.set(block.scale[0], block.scale[1], block.scale[2]);

          matrix.compose(position, rotation, scale);
          instancedMesh.setMatrixAt(i, matrix);
        });

        instancedMesh.instanceMatrix.needsUpdate = true;
        this.voxelGroup.add(instancedMesh);
      });

      // Create outline boxes for each selected component (one box per component)
      selectedBlocksByComponent.forEach((componentBlocks, componentId) => {
        if (componentBlocks.length > 0) {
          // Calculate bounding box of this component's blocks
          let minX = Infinity, maxX = -Infinity;
          let minY = Infinity, maxY = -Infinity;
          let minZ = Infinity, maxZ = -Infinity;

          componentBlocks.forEach(block => {
            // Account for block scale (assuming uniform scale of 1 for now)
            const halfScale = 0.5;
            minX = Math.min(minX, block.x - halfScale);
            maxX = Math.max(maxX, block.x + halfScale);
            minY = Math.min(minY, block.y - halfScale);
            maxY = Math.max(maxY, block.y + halfScale);
            minZ = Math.min(minZ, block.z - halfScale);
            maxZ = Math.max(maxZ, block.z + halfScale);
          });

          // Create box outline geometry
          const width = maxX - minX;
          const height = maxY - minY;
          const depth = maxZ - minZ;
          const centerX = (minX + maxX) / 2;
          const centerY = (minY + maxY) / 2;
          const centerZ = (minZ + maxZ) / 2;

          // Use EdgesGeometry for clean, accurate edges
          const boxGeometry = new THREE.BoxGeometry(width, height, depth);
          const edges = new THREE.EdgesGeometry(boxGeometry);

          // Bright cyan outline that stands out
          const lineMaterial = new THREE.LineBasicMaterial({
            color: 0x00ffff,  // Cyan
            linewidth: 2,      // Note: linewidth > 1 only works with WebGLRenderer on some systems
            transparent: false,
            depthTest: true,   // Respects depth so it doesn't show through objects
          });

          const highlightBox = new THREE.LineSegments(edges, lineMaterial);
          highlightBox.position.set(centerX, centerY, centerZ);

          // Add to scene and store in array
          this.scene.add(highlightBox);
          this.highlightBoxes.push(highlightBox);
        }
      });

      console.log(`Loaded ${voxelData.length} voxels using ${blockGroups.size} instanced meshes`);
    }

    animate() {
      this.animationId = requestAnimationFrame(() => this.animate());

      // Update controls for damping/smoothing
      if (this.controls) {
        this.controls.update();
      }

      this.renderer.render(this.scene, this.camera);

      // Update compass to match main camera orientation
      if (this.compassScene.children.length > 0) {
        const axesGroup = this.compassScene.children[0];
        axesGroup.quaternion.copy(this.camera.quaternion).invert();
        this.compassRenderer.render(this.compassScene, this.compassCamera);
      }
    }

    onWindowResize() {
      const width = this.container.clientWidth;
      const height = this.container.clientHeight;

      this.camera.aspect = width / height;
      this.camera.updateProjectionMatrix();

      this.renderer.setSize(width, height);
    }

    selectComponent(componentId: string) {
      // Toggle selection for this component
      if (this.selectedComponents.has(componentId)) {
        this.selectedComponents.delete(componentId);
      } else {
        this.selectedComponents.clear();
        this.selectedComponents.add(componentId);
      }
      // Re-render with new selection
      this.renderVoxels();
    }

    toggleComponentVisibility(componentId: string) {
      if (this.hiddenComponents.has(componentId)) {
        this.hiddenComponents.delete(componentId);
      } else {
        this.hiddenComponents.add(componentId);
      }
      this.renderVoxels();
    }

    clearSelection() {
      this.selectedComponents.clear();
      this.renderVoxels();
    }

    selectMultipleComponents(componentIds: string[]) {
      // Set multiple components as selected
      this.selectedComponents.clear();
      componentIds.forEach(id => this.selectedComponents.add(id));
      this.renderVoxels();
    }

    deleteComponents(componentIds: string[]) {
      // Save state before deletion
      this.saveState();

      // Remove blocks that belong to these components
      const indicesToDelete = new Set<number>();

      // Find all block indices for components being deleted
      componentIds.forEach(componentId => {
        if (this.componentBlockRanges.has(componentId)) {
          const range = this.componentBlockRanges.get(componentId)!;
          for (let i = range.start; i <= range.end; i++) {
            indicesToDelete.add(i);
          }
          // Remove component metadata
          this.componentBlockRanges.delete(componentId);
        }
      });

      // Create new voxelData array without deleted blocks
      const newVoxelData = this.voxelData.filter((_, index) => !indicesToDelete.has(index));

      // Update component block ranges to account for removed blocks
      const deletedIndicesSorted = Array.from(indicesToDelete).sort((a, b) => a - b);
      const newComponentBlockRanges = new Map<string, { start: number; end: number }>();

      this.componentBlockRanges.forEach((range, componentId) => {
        // Count how many blocks before this range were deleted
        let offsetBefore = 0;
        for (const deletedIndex of deletedIndicesSorted) {
          if (deletedIndex < range.start) {
            offsetBefore++;
          } else {
            break;
          }
        }

        // Count how many blocks in this range were deleted
        let deletedInRange = 0;
        for (const deletedIndex of deletedIndicesSorted) {
          if (deletedIndex >= range.start && deletedIndex <= range.end) {
            deletedInRange++;
          }
        }

        // Update range with new indices
        newComponentBlockRanges.set(componentId, {
          start: range.start - offsetBefore,
          end: range.end - offsetBefore - deletedInRange
        });
      });

      // Remove components from the components array
      this.components = this.components.filter(comp => !componentIds.includes(comp.id));

      // Update state
      this.voxelData = newVoxelData;
      this.componentBlockRanges = newComponentBlockRanges;

      // Clear selection if deleted components were selected
      componentIds.forEach(id => this.selectedComponents.delete(id));

      // Re-render
      this.renderVoxels();

      console.log(`Deleted ${componentIds.length} component(s), ${indicesToDelete.size} blocks removed`);
    }

    showAllComponents() {
      this.hiddenComponents.clear();
      this.renderVoxels();
    }

    rescaleModel(scalePercent: number) {
      const scaleFactor = scalePercent / 100;
      this.currentScale = scaleFactor;

      if (scaleFactor === 1.0) {
        // Return to original
        this.voxelData = JSON.parse(JSON.stringify(this.originalVoxelData));
        this.renderVoxels();
        return;
      }

      const originalData = this.originalVoxelData;

      if (scaleFactor > 1.0) {
        // UPSCALE: subdivide each block
        const newVoxelData: any[] = [];
        const subdivisions = Math.round(scaleFactor);

        originalData.forEach(voxel => {
          // Each block becomes subdivisions^3 smaller blocks
          for (let dx = 0; dx < subdivisions; dx++) {
            for (let dy = 0; dy < subdivisions; dy++) {
              for (let dz = 0; dz < subdivisions; dz++) {
                newVoxelData.push({
                  block: voxel.block,
                  x: voxel.x * subdivisions + dx,
                  y: voxel.y * subdivisions + dy,
                  z: voxel.z * subdivisions + dz,
                  scale: voxel.scale || [1, 1, 1],
                  brightness: voxel.brightness,
                  color: voxel.color // Preserve AI-provided color
                });
              }
            }
          }
        });

        this.voxelData = newVoxelData;
      } else {
        // DOWNSCALE: use voxel grid to group and reduce blocks
        const downsampledMap = new Map<string, any>();

        originalData.forEach(voxel => {
          // Scale the coordinates first
          const scaledX = voxel.x * scaleFactor;
          const scaledY = voxel.y * scaleFactor;
          const scaledZ = voxel.z * scaleFactor;

          // Round to nearest 0.5 to create grid cells
          // This groups nearby blocks together
          const gridSize = 0.5;
          const gridX = Math.round(scaledX / gridSize) * gridSize;
          const gridY = Math.round(scaledY / gridSize) * gridSize;
          const gridZ = Math.round(scaledZ / gridSize) * gridSize;

          const key = `${gridX.toFixed(1)},${gridY.toFixed(1)},${gridZ.toFixed(1)}`;

          // Keep first block at each grid position
          if (!downsampledMap.has(key)) {
            downsampledMap.set(key, {
              block: voxel.block,
              x: gridX,
              y: gridY,
              z: gridZ,
              scale: voxel.scale || [1, 1, 1],
              brightness: voxel.brightness,
              color: voxel.color // Preserve AI-provided color
            });
          }
        });

        this.voxelData = Array.from(downsampledMap.values());
      }

      this.renderVoxels();
      console.log(`Rescaled model to ${scalePercent}% (${this.voxelData.length} blocks)`);
    }

    rotateComponents(componentIds: string[], axis: 'x' | 'y' | 'z', degrees: number) {
      // Save state before rotation
      this.saveState();

      // First, find the bounding box of ALL selected components together
      // This ensures multiple components rotate around a shared center point
      let globalMinX = Infinity, globalMinY = Infinity, globalMinZ = Infinity;
      let globalMaxX = -Infinity, globalMaxY = -Infinity, globalMaxZ = -Infinity;

      componentIds.forEach(componentId => {
        if (!this.componentBlockRanges.has(componentId)) return;
        const range = this.componentBlockRanges.get(componentId)!;

        for (let i = range.start; i <= range.end; i++) {
          if (i < this.voxelData.length) {
            globalMinX = Math.min(globalMinX, this.voxelData[i].x);
            globalMinY = Math.min(globalMinY, this.voxelData[i].y);
            globalMinZ = Math.min(globalMinZ, this.voxelData[i].z);
            globalMaxX = Math.max(globalMaxX, this.voxelData[i].x);
            globalMaxY = Math.max(globalMaxY, this.voxelData[i].y);
            globalMaxZ = Math.max(globalMaxZ, this.voxelData[i].z);
          }
        }
      });

      // Calculate the center of the group
      const centerX = (globalMinX + globalMaxX) / 2;
      const centerY = (globalMinY + globalMaxY) / 2;
      const centerZ = (globalMinZ + globalMaxZ) / 2;

      // Now rotate all blocks around this shared center
      componentIds.forEach(componentId => {
        if (!this.componentBlockRanges.has(componentId)) return;
        const range = this.componentBlockRanges.get(componentId)!;

        // Apply 90-degree rotation using voxel grid transformation
        for (let i = range.start; i <= range.end; i++) {
          if (i < this.voxelData.length) {
            const block = this.voxelData[i];

            // Translate to center (rotate around shared center point)
            let x = block.x - centerX;
            let y = block.y - centerY;
            let z = block.z - centerZ;

            let newX, newY, newZ;

            // Apply rotation (coordinate swapping for 90-degree rotations)
            if (degrees === 90) {
              if (axis === 'x') {
                // Rotate around X: Y->Z, Z->-Y
                newX = x;
                newY = -z;
                newZ = y;
              } else if (axis === 'y') {
                // Rotate around Y: X->Z, Z->-X
                newX = -z;
                newY = y;
                newZ = x;
              } else { // z
                // Rotate around Z: X->Y, Y->-X
                newX = -y;
                newY = x;
                newZ = z;
              }
            } else if (degrees === -90) {
              if (axis === 'x') {
                // Rotate around X: Y->-Z, Z->Y
                newX = x;
                newY = z;
                newZ = -y;
              } else if (axis === 'y') {
                // Rotate around Y: X->-Z, Z->X
                newX = z;
                newY = y;
                newZ = -x;
              } else { // z
                // Rotate around Z: X->-Y, Y->X
                newX = y;
                newY = -x;
                newZ = z;
              }
            } else {
              newX = x;
              newY = y;
              newZ = z;
            }

            // Translate back using the shared center
            block.x = newX + centerX;
            block.y = newY + centerY;
            block.z = newZ + centerZ;
          }
        }
      });

      this.renderVoxels();
      console.log(`Rotated ${componentIds.length} component(s) ${degrees} around ${axis}-axis`);
    }

    moveComponents(componentIds: string[], axis: 'x' | 'y' | 'z', amount: number) {
      // Save state before moving
      this.saveState();

      // Process each component
      componentIds.forEach(componentId => {
        if (!this.componentBlockRanges.has(componentId)) return;

        const range = this.componentBlockRanges.get(componentId)!;
        for (let i = range.start; i <= range.end; i++) {
          if (i < this.voxelData.length) {
            const block = this.voxelData[i];
            if (axis === 'x') block.x += amount;
            else if (axis === 'y') block.y += amount;
            else if (axis === 'z') block.z += amount;
          }
        }
      });

      this.renderVoxels();
      console.log(`Moved ${componentIds.length} component(s) ${amount} units along ${axis}-axis`);
    }

    onMouseMove(event: MouseEvent) {
      // Calculate mouse position in normalized device coordinates (-1 to +1)
      const rect = this.renderer.domElement.getBoundingClientRect();
      this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

      // Update raycaster
      this.raycaster.setFromCamera(this.mouse, this.camera);

      // Check for intersections to show tooltip
      const intersects = this.raycaster.intersectObjects(this.voxelGroup.children, true);

      if (intersects.length > 0) {
        const componentId = this.getComponentIdFromIntersection(intersects[0]);

        if (componentId && componentId !== this.hoveredComponent) {
          this.hoveredComponent = componentId;

          // Find component description
          const component = this.components.find(c => c.id === componentId);
          if (component) {
            this.tooltip.textContent = component.description || componentId;
            this.tooltip.style.display = 'block';
          }
        }

        // Position tooltip near cursor
        this.tooltip.style.left = `${event.clientX + 15}px`;
        this.tooltip.style.top = `${event.clientY + 15}px`;
      } else {
        this.hoveredComponent = null;
        this.tooltip.style.display = 'none';
      }
    }

    getComponentIdFromIntersection(intersection: any): string | null {
      // Get the instance index from the intersection
      if (intersection.instanceId !== undefined) {
        const instanceIndex = intersection.instanceId;

        // Find which component this block belongs to
        for (const [componentId, range] of this.componentBlockRanges.entries()) {
          if (instanceIndex >= range.start && instanceIndex <= range.end) {
            return componentId;
          }
        }
      }

      return null;
    }

    destroy() {
      if (this.animationId !== null) {
        cancelAnimationFrame(this.animationId);
      }
      if (this.controls) {
        this.controls.dispose();
      }
      if (this.tooltip && this.tooltip.parentNode) {
        this.tooltip.parentNode.removeChild(this.tooltip);
      }
      this.container.removeChild(this.renderer.domElement);
      this.renderer.dispose();

      // Clean up compass
      this.compassRenderer.dispose();
      if (this.container.contains(this.compassRenderer.domElement)) {
        this.container.removeChild(this.compassRenderer.domElement);
      }
    }
  };
</script>

<style>
  #voxel-viewer {
    cursor: grab;
  }

  #voxel-viewer:active {
    cursor: grabbing;
  }
</style>
