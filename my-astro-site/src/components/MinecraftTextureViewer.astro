---
// Minecraft-Style Viewer with Real Textures
// Uses Three.js to render blocks with actual Minecraft textures
---

<div id="minecraft-viewer-container" class="w-full h-full"></div>

<script>
  import * as THREE from 'three';
  import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';

  // Texture mapping: simplified name -> texture filename
  const TEXTURE_MAP: Record<string, string> = {
    'stone': 'stone.png',
    'dirt': 'dirt.png',
    'grass': 'grass_block_side.png',
    'grass_block': 'grass_block_side.png',
    'sand': 'sand.png',
    'wood': 'oak_planks.png',
    'planks': 'oak_planks.png',
    'oak_planks': 'oak_planks.png',
    'glass': 'glass.png',
    'white_concrete': 'white_concrete.png',
    'orange_concrete': 'orange_concrete.png',
    'magenta_concrete': 'magenta_concrete.png',
    'light_blue_concrete': 'light_blue_concrete.png',
    'yellow_concrete': 'yellow_concrete.png',
    'lime_concrete': 'lime_concrete.png',
    'pink_concrete': 'pink_concrete.png',
    'gray_concrete': 'gray_concrete.png',
    'light_gray_concrete': 'light_gray_concrete.png',
    'cyan_concrete': 'cyan_concrete.png',
    'purple_concrete': 'purple_concrete.png',
    'blue_concrete': 'blue_concrete.png',
    'brown_concrete': 'brown_concrete.png',
    'green_concrete': 'green_concrete.png',
    'red_concrete': 'red_concrete.png',
    'black_concrete': 'black_concrete.png',
    'white': 'white_concrete.png',
    'orange': 'orange_concrete.png',
    'yellow': 'yellow_concrete.png',
    'lime': 'lime_concrete.png',
    'pink': 'pink_concrete.png',
    'gray': 'gray_concrete.png',
    'cyan': 'cyan_concrete.png',
    'purple': 'purple_concrete.png',
    'blue': 'blue_concrete.png',
    'brown': 'brown_concrete.png',
    'green': 'green_concrete.png',
    'red': 'red_concrete.png',
    'black': 'black_concrete.png',
    'concrete': 'white_concrete.png',
    'wool': 'white_wool.png',
    'white_wool': 'white_wool.png',
    'terracotta': 'terracotta.png',
    'iron': 'iron_block.png',
    'iron_block': 'iron_block.png',
    'gold': 'gold_block.png',
    'gold_block': 'gold_block.png',
    'diamond': 'diamond_block.png',
    'diamond_block': 'diamond_block.png',
    'emerald': 'emerald_block.png',
    'emerald_block': 'emerald_block.png',
    'obsidian': 'obsidian.png',
    'bedrock': 'bedrock.png',
    'brick': 'bricks.png',
    'bricks': 'bricks.png',
    'cobblestone': 'cobblestone.png',
    'stone_bricks': 'stone_bricks.png',
    'oak_log': 'oak_log.png',
    'spruce_log': 'spruce_log.png',
    'birch_log': 'birch_log.png',
    'jungle_log': 'jungle_log.png',
    'leaves': 'oak_leaves.png',
    'oak_leaves': 'oak_leaves.png',
    'glowstone': 'glowstone.png',
    'sea_lantern': 'sea_lantern.png',
    'quartz': 'quartz_block_side.png',
    'quartz_block': 'quartz_block_side.png',
    'prismarine': 'prismarine.png',
    'netherrack': 'netherrack.png',
    'end_stone': 'end_stone.png',
  };

  export class MinecraftTextureViewer {
    scene: THREE.Scene;
    camera: THREE.PerspectiveCamera;
    renderer: THREE.WebGLRenderer;
    controls: OrbitControls;
    textureLoader: THREE.TextureLoader;
    textureCache: Map<string, THREE.Texture> = new Map();
    container: HTMLElement;

    constructor(containerId: string) {
      const container = document.getElementById(containerId);
      if (!container) throw new Error(`Container ${containerId} not found`);
      this.container = container;

      // Scene
      this.scene = new THREE.Scene();
      this.scene.background = new THREE.Color(0x87CEEB); // Sky blue like Minecraft

      // Camera
      const width = container.clientWidth;
      const height = container.clientHeight;
      this.camera = new THREE.PerspectiveCamera(70, width / height, 0.1, 1000);

      // Renderer
      this.renderer = new THREE.WebGLRenderer({ antialias: false }); // Pixelated like Minecraft
      this.renderer.setSize(width, height);
      this.renderer.setPixelRatio(1); // Keep it pixel-perfect
      container.appendChild(this.renderer.domElement);

      // Lights - simple like Minecraft
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      this.scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.4);
      directionalLight.position.set(50, 100, 50);
      this.scene.add(directionalLight);

      // Controls
      this.controls = new OrbitControls(this.camera, this.renderer.domElement);
      this.controls.enableDamping = true;
      this.controls.dampingFactor = 0.05;
      this.controls.minDistance = 2;
      this.controls.maxDistance = 500;

      // Texture loader with nearest neighbor filtering (pixelated)
      this.textureLoader = new THREE.TextureLoader();

      // Animate
      this.animate();
    }

    getTexture(blockName: string): THREE.Texture {
      // Check cache first
      if (this.textureCache.has(blockName)) {
        return this.textureCache.get(blockName)!;
      }

      // Get texture filename
      const textureFile = TEXTURE_MAP[blockName] || TEXTURE_MAP[blockName.replace('minecraft:', '')] || 'stone.png';
      const texturePath = `/textures/block/${textureFile}`;

      // Load texture
      const texture = this.textureLoader.load(
        texturePath,
        undefined,
        undefined,
        () => {
          // Fallback to stone if texture not found
          console.warn(`Texture not found: ${texturePath}, using stone`);
          const fallback = this.textureLoader.load('/textures/block/stone.png');
          fallback.magFilter = THREE.NearestFilter;
          fallback.minFilter = THREE.NearestFilter;
          this.textureCache.set(blockName, fallback);
        }
      );

      // Pixelated filtering (like Minecraft)
      texture.magFilter = THREE.NearestFilter;
      texture.minFilter = THREE.NearestFilter;

      this.textureCache.set(blockName, texture);
      return texture;
    }

    loadBlocks(blocks: Array<{ x: number; y: number; z: number; blockName: string }>) {
      // Clear existing blocks
      while (this.scene.children.length > 2) { // Keep lights
        this.scene.remove(this.scene.children[2]);
      }

      // Group blocks by type for instancing
      const blocksByType = new Map<string, Array<{x: number, y: number, z: number}>>();

      blocks.forEach(block => {
        if (!blocksByType.has(block.blockName)) {
          blocksByType.set(block.blockName, []);
        }
        blocksByType.get(block.blockName)!.push({ x: block.x, y: block.y, z: block.z });
      });

      // Create instanced meshes for each block type
      const geometry = new THREE.BoxGeometry(1, 1, 1);

      blocksByType.forEach((positions, blockName) => {
        const texture = this.getTexture(blockName);
        const material = new THREE.MeshLambertMaterial({ map: texture });

        const mesh = new THREE.InstancedMesh(geometry, material, positions.length);

        positions.forEach((pos, index) => {
          const matrix = new THREE.Matrix4();
          matrix.setPosition(pos.x, pos.y, pos.z);
          mesh.setMatrixAt(index, matrix);
        });

        mesh.instanceMatrix.needsUpdate = true;
        this.scene.add(mesh);
      });

      // Center camera on model
      if (blocks.length > 0) {
        const centerX = blocks.reduce((sum, b) => sum + b.x, 0) / blocks.length;
        const centerY = blocks.reduce((sum, b) => sum + b.y, 0) / blocks.length;
        const centerZ = blocks.reduce((sum, b) => sum + b.z, 0) / blocks.length;

        const maxDist = Math.max(
          ...blocks.map(b => Math.sqrt((b.x - centerX) ** 2 + (b.y - centerY) ** 2 + (b.z - centerZ) ** 2))
        );

        this.camera.position.set(
          centerX + maxDist * 2,
          centerY + maxDist,
          centerZ + maxDist * 2
        );
        this.camera.lookAt(centerX, centerY, centerZ);
        this.controls.target.set(centerX, centerY, centerZ);
      }

      console.log(`[MinecraftViewer] Loaded ${blocks.length} blocks with real textures`);
    }

    animate = () => {
      requestAnimationFrame(this.animate);
      this.controls.update();
      this.renderer.render(this.scene, this.camera);
    };

    destroy() {
      this.renderer.dispose();
      this.container.removeChild(this.renderer.domElement);
    }
  }

  // Make globally accessible
  (window as any).MinecraftTextureViewer = MinecraftTextureViewer;
</script>
