---
// Interactive Voxel Model Generator Demo
import VoxelViewer from './VoxelViewer.astro';
import BlockPalette from './BlockPalette/BlockPalette.tsx';
import DocsPanel from './DocsPanel/DocsPanel.tsx';
import './BlockAutocomplete.css';
---

<div class="bg-white rounded-3xl shadow-soft p-8 border border-gray-200 w-full">
  <div class="mb-6">
    <h1 class="text-4xl font-display font-bold text-gray-900 mb-2">
      üé® AI Voxel Model Generator
    </h1>
    <p class="text-sm text-gray-600">
      Create 3D Minecraft models using Python code. Use AI to generate code, or write your own.
    </p>
  </div>

  <!-- Two-column layout for AI vs Manual -->
  <div class="grid grid-cols-1 md:grid-cols-[1fr_auto] gap-4 mb-4">
    <!-- AI Generation Section -->
    <div class="border-2 border-orange-200 rounded-2xl p-4 bg-orange-50/30">
      <h3 class="text-sm font-display font-semibold text-orange-900 mb-3 flex items-center gap-2">
        <span>ü§ñ</span>
        <span>AI Generation</span>
      </h3>

      <div class="mb-3">
        <label class="block text-xs font-display font-semibold text-gray-700 mb-1.5">
          Complexity Level
        </label>
        <select
          id="complexity-select"
          class="w-full px-3 py-2 border-2 border-gray-200 rounded-xl focus:border-orange-500 focus:outline-none font-body bg-white text-sm"
        >
          <option value="small">Simple - Clean silhouette, instantly recognizable</option>
          <option value="medium" selected>Medium - Clear features, good proportions, some detail</option>
          <option value="large">Detailed - Smooth surfaces, intricate features, multiple materials</option>
          <option value="ultra">Ultra-Detailed - Masterpiece quality, maximum fidelity</option>
          <option value="custom">AI Decides - Full creative freedom</option>
        </select>
      </div>

      <div class="flex items-end gap-2">
        <div class="flex-1">
          <label class="block text-xs font-display font-semibold text-gray-700 mb-1.5">
            What do you want to build?
          </label>
          <input
            id="voxel-input"
            type="text"
            placeholder="Try: Pikachu, Dragon, Castle, Tree..."
            class="w-full px-3 py-2 border-2 border-gray-200 rounded-xl focus:border-orange-500 focus:outline-none font-body text-sm"
            maxlength="200"
          />
        </div>
        <button
          id="generate-btn"
          class="px-5 py-2 bg-gradient-to-r from-orange to-orange-dark text-white font-display font-semibold rounded-xl hover:shadow-lg hover:scale-105 transition-all duration-200 disabled:opacity-50 disabled:cursor-not-allowed whitespace-nowrap"
        >
          Generate
        </button>
        <button
          id="copy-prompt-btn"
          class="px-5 py-2 bg-gradient-to-r from-aqua to-teal text-white font-display font-semibold rounded-xl hover:shadow-lg hover:scale-105 transition-all duration-200 whitespace-nowrap"
        >
          Copy Prompt
        </button>
      </div>
    </div>

    <!-- Manual Creation Section -->
    <div class="border-2 border-purple-200 rounded-2xl p-4 bg-purple-50/30 flex flex-col justify-center items-center min-w-[200px]">
      <h3 class="text-sm font-display font-semibold text-purple-900 mb-3 flex items-center gap-2">
        <span>‚úçÔ∏è</span>
        <span>Manual Creation</span>
      </h3>
      <button
        id="create-btn"
        class="px-6 py-3 bg-gradient-to-r from-purple-500 to-purple-700 text-white font-display font-semibold rounded-xl hover:shadow-lg hover:scale-105 transition-all duration-200"
      >
        Start from Blank
      </button>
      <p class="text-xs text-gray-600 mt-2 text-center">
        Write Python code yourself
      </p>
    </div>
  </div>

    <div id="rate-limit-info" class="text-xs text-gray-500 mb-4">
      <!-- Rate limit info will be shown here -->
    </div>

    <div id="prompt-preview" class="hidden p-4 bg-gray-50 rounded-xl mb-4">
      <div class="flex items-start justify-between mb-2">
        <span class="text-xs font-semibold text-gray-600">COPIED TO CLIPBOARD - Paste into your preferred AI chat:</span>
        <span id="copied-indicator" class="text-xs text-green-600 font-semibold">‚úì Copied!</span>
      </div>
      <div class="flex gap-3 mt-3">
        <a
          href="https://chatgpt.com"
          target="_blank"
          rel="noopener noreferrer"
          class="inline-flex items-center gap-2 px-4 py-2 bg-white border-2 border-gray-300 rounded-xl hover:border-aqua transition-colors text-sm font-medium"
        >
          <span>Open ChatGPT ‚Üí</span>
        </a>
        <a
          href="https://claude.ai"
          target="_blank"
          rel="noopener noreferrer"
          class="inline-flex items-center gap-2 px-4 py-2 bg-white border-2 border-gray-300 rounded-xl hover:border-aqua transition-colors text-sm font-medium"
        >
          <span>Open Claude ‚Üí</span>
        </a>
        <a
          href="https://gemini.google.com/app"
          target="_blank"
          rel="noopener noreferrer"
          class="inline-flex items-center gap-2 px-4 py-2 bg-white border-2 border-gray-300 rounded-xl hover:border-aqua transition-colors text-sm font-medium"
        >
          <span>Open Gemini ‚Üí</span>
        </a>
        <a
          href="https://grok.com"
          target="_blank"
          rel="noopener noreferrer"
          class="inline-flex items-center gap-2 px-4 py-2 bg-white border-2 border-gray-300 rounded-xl hover:border-aqua transition-colors text-sm font-medium"
        >
          <span>Open Grok ‚Üí</span>
        </a>
      </div>
    </div>

    <!-- Step 2: Paste Response -->
    <div id="paste-section" class="hidden">
      <label class="block text-sm font-display font-semibold text-gray-700 mb-2">
        Paste the Python code response here:
      </label>
      <textarea
        id="python-code-input"
        rows="10"
        placeholder="Paste the Python code from your AI chat here..."
        class="w-full px-4 py-3 border-2 border-gray-200 rounded-xl focus:border-aqua focus:outline-none font-mono text-sm bg-white"
      ></textarea>

      <button
        id="visualize-btn"
        class="mt-3 px-8 py-3 bg-gradient-to-r from-orange to-orange-dark text-white font-display font-semibold rounded-2xl hover:shadow-lg hover:scale-105 transition-all duration-200 disabled:opacity-50 disabled:cursor-not-allowed"
      >
        üé® Visualize Model
      </button>
    </div>

    <!-- Code Editor Section (shown after any generation or when Create is clicked) -->
    <div id="code-editor-section" class="hidden mt-6">
      <div class="flex items-center justify-between mb-2">
        <label class="block text-sm font-display font-semibold text-gray-700">
          Python Code Editor
        </label>
        <div class="flex gap-2">
          <button
            id="toggle-blocks-btn"
            class="px-3 py-1 text-xs bg-purple-100 hover:bg-purple-200 text-purple-700 font-medium rounded-lg transition-colors"
            title="Browse available Minecraft blocks"
          >
            üì¶ Blocks
          </button>
          <button
            id="toggle-docs-btn"
            class="px-3 py-1 text-xs bg-blue-100 hover:bg-blue-200 text-blue-700 font-medium rounded-lg transition-colors"
          >
            üìö API Docs
          </button>
          <button
            id="export-manual-edits-btn"
            class="px-3 py-1 text-xs bg-green-100 hover:bg-green-200 text-green-700 font-medium rounded-lg transition-colors hidden"
            title="Export manual rotations/moves/deletes as code"
          >
            üì§ Export Edits
          </button>
          <button
            id="reset-code-btn"
            class="px-3 py-1 text-xs bg-gray-100 hover:bg-gray-200 text-gray-700 font-medium rounded-lg transition-colors"
          >
            Reset
          </button>
          <button
            id="regenerate-btn"
            class="px-4 py-1 bg-gradient-to-r from-purple-500 to-purple-700 hover:from-purple-600 hover:to-purple-800 text-white font-semibold rounded-lg transition-all disabled:opacity-50 disabled:cursor-not-allowed"
          >
            ‚ñ∂ Regenerate
          </button>
        </div>
      </div>
      <div id="manual-edits-warning" class="hidden text-xs bg-yellow-50 border border-yellow-200 rounded px-2 py-1 mb-2">
        <span class="text-yellow-700">‚ö†Ô∏è You have manual edits (rotate/move/delete). Click "Export Edits" to save them as code, or they'll be lost when you regenerate.</span>
      </div>
      <div class="text-xs text-gray-500 mb-2">
        Edit the code and click Regenerate to see your changes.
      </div>

      <textarea
        id="code-editor"
        rows="20"
        class="w-full px-4 py-3 border-2 border-gray-300 rounded-xl focus:border-purple-500 focus:outline-none font-mono text-sm bg-gray-50"
        spellcheck="false"
      ></textarea>
    </div>

  </div>

  <!-- Shared Result Section (used by both Live Demo and Free Option) -->
  <div id="result" class="hidden mt-6">
    <!-- 2 Column Layout: Sidebar + Viewer -->
    <div class="grid grid-cols-1 lg:grid-cols-[400px_1fr] gap-6">
      <!-- LEFT SIDEBAR: Controls, Stats, Components -->
      <div class="space-y-4">
        <!-- FIXED CONTROLS (Always visible at top) -->
        <div class="space-y-4">
          <!-- Header Buttons -->
          <div class="flex flex-wrap gap-2">
            <button type="button" id="minecraft-preview-btn" class="px-3 py-1 bg-gradient-to-r from-green-500 to-green-600 hover:from-green-600 hover:to-green-700 text-white border-2 border-green-700 rounded text-sm font-medium shadow-sm" title="Preview Minecraft Export">Minecraft View</button>
            <button id="undo-btn" class="px-2 py-1 bg-white hover:bg-gray-50 border-2 border-gray-300 hover:border-gray-400 rounded text-lg font-medium disabled:opacity-50 disabled:cursor-not-allowed shadow-sm" title="Undo (Ctrl+Z)">‚Ü∂</button>
            <button id="redo-btn" class="px-2 py-1 bg-white hover:bg-gray-50 border-2 border-gray-300 hover:border-gray-400 rounded text-lg font-medium disabled:opacity-50 disabled:cursor-not-allowed shadow-sm" title="Redo (Ctrl+Y)">‚Ü∑</button>
          </div>

          <!-- Transform Controls (shown when components selected) -->
          <div id="global-transform-controls" class="hidden p-3 bg-blue-50 rounded-lg border border-blue-200">
            <div class="text-xs font-semibold text-blue-900 mb-2">Transform Selected Components</div>
            <div class="flex gap-4">
              <div class="flex-1">
                <div class="text-xs font-semibold text-gray-700 mb-1">Move:</div>
                <div class="grid grid-cols-3 gap-1">
                  <button class="global-move-btn px-2 py-1 bg-red-100 hover:bg-red-200 border-2 border-red-300 hover:border-red-400 rounded text-base font-medium shadow-sm" data-axis="x" data-amount="-1" title="Move Left (X)">‚¨Ö<span class="text-xs ml-1">X</span></button>
                  <button class="global-move-btn px-2 py-1 bg-red-100 hover:bg-red-200 border-2 border-red-300 hover:border-red-400 rounded text-base font-medium shadow-sm" data-axis="x" data-amount="1" title="Move Right (X)">‚û°<span class="text-xs ml-1">X</span></button>
                  <div></div>
                  <button class="global-move-btn px-2 py-1 bg-green-100 hover:bg-green-200 border-2 border-green-300 hover:border-green-400 rounded text-base font-medium shadow-sm" data-axis="y" data-amount="-1" title="Move Down (Y)">‚¨á<span class="text-xs ml-1">Y</span></button>
                  <button class="global-move-btn px-2 py-1 bg-green-100 hover:bg-green-200 border-2 border-green-300 hover:border-green-400 rounded text-base font-medium shadow-sm" data-axis="y" data-amount="1" title="Move Up (Y)">‚¨Ü<span class="text-xs ml-1">Y</span></button>
                  <div></div>
                  <button class="global-move-btn px-2 py-1 bg-blue-100 hover:bg-blue-200 border-2 border-blue-300 hover:border-blue-400 rounded text-base font-medium shadow-sm" data-axis="z" data-amount="-1" title="Move Back (Z)">‚¨Ö<span class="text-xs ml-1">Z</span></button>
                  <button class="global-move-btn px-2 py-1 bg-blue-100 hover:bg-blue-200 border-2 border-blue-300 hover:border-blue-400 rounded text-base font-medium shadow-sm" data-axis="z" data-amount="1" title="Move Forward (Z)">‚û°<span class="text-xs ml-1">Z</span></button>
                </div>
              </div>
              <div class="flex-1">
                <div class="text-xs font-semibold text-gray-700 mb-1">Rotate:</div>
                <div class="grid grid-cols-2 gap-1">
                  <button class="global-rotate-btn px-2 py-1 bg-blue-100 hover:bg-blue-200 border-2 border-blue-300 hover:border-blue-400 rounded text-base font-medium shadow-sm" data-axis="z" data-degrees="-90" title="Roll Left (Z)">‚Ü∫<span class="text-xs ml-1">90¬∞</span></button>
                  <button class="global-rotate-btn px-2 py-1 bg-blue-100 hover:bg-blue-200 border-2 border-blue-300 hover:border-blue-400 rounded text-base font-medium shadow-sm" data-axis="z" data-degrees="90" title="Roll Right (Z)">‚Üª<span class="text-xs ml-1">90¬∞</span></button>
                  <button class="global-rotate-btn px-2 py-1 bg-green-100 hover:bg-green-200 border-2 border-green-300 hover:border-green-400 rounded text-base font-medium shadow-sm" data-axis="y" data-degrees="-90" title="Turn Left (Y)">‚Ü∂<span class="text-xs ml-1">90¬∞</span></button>
                  <button class="global-rotate-btn px-2 py-1 bg-green-100 hover:bg-green-200 border-2 border-green-300 hover:border-green-400 rounded text-base font-medium shadow-sm" data-axis="y" data-degrees="90" title="Turn Right (Y)">‚Ü∑<span class="text-xs ml-1">90¬∞</span></button>
                  <button class="global-rotate-btn px-2 py-1 bg-red-100 hover:bg-red-200 border-2 border-red-300 hover:border-red-400 rounded text-base font-medium shadow-sm" data-axis="x" data-degrees="-90" title="Tilt Down (X)">‚§µ<span class="text-xs ml-1">90¬∞</span></button>
                  <button class="global-rotate-btn px-2 py-1 bg-red-100 hover:bg-red-200 border-2 border-red-300 hover:border-red-400 rounded text-base font-medium shadow-sm" data-axis="x" data-degrees="90" title="Tilt Up (X)">‚§¥<span class="text-xs ml-1">90¬∞</span></button>
                </div>
              </div>
            </div>
          </div>

          <!-- Placement Mode Toggle (hidden until generation) -->
          <div id="placement-mode-toggle" class="hidden flex justify-center">
            <div class="inline-flex items-center bg-white border-2 border-gray-300 rounded-lg overflow-hidden shadow-sm">
              <button id="mode-display-btn" class="px-4 py-1.5 text-xs font-medium bg-aqua text-white transition-colors">
                Display Blocks
              </button>
              <button id="mode-blocks-btn" class="px-4 py-1.5 text-xs font-medium text-gray-700 hover:bg-aqua hover:text-white transition-colors">
                Real Blocks
              </button>
            </div>
          </div>
        </div>

        <!-- SCROLLABLE CONTENT (Component Catalog & Export) -->
        <div class="space-y-4 max-h-[calc(100vh-450px)] overflow-y-auto pr-2">
          <!-- Model Stats -->
          <div id="model-stats" class="grid grid-cols-1 gap-3 text-sm">
            <!-- Stats will be populated here -->
          </div>

          <!-- Components List -->
          <div id="components-section" class="hidden border-t border-gray-200 pt-4">
            <div class="flex items-center justify-between mb-2">
              <h5 class="text-sm font-display font-semibold text-gray-700">üß© Components (<span id="component-count">0</span>):</h5>
              <div class="flex gap-2">
                <button id="show-all-components" class="px-2 py-1 bg-white hover:bg-gray-50 border-2 border-gray-300 hover:border-gray-400 rounded text-xs font-medium shadow-sm" title="Show All">üëÅÔ∏è Show All</button>
                <button id="delete-selected-components" class="hidden px-2 py-1 bg-red-50 hover:bg-red-100 border-2 border-red-300 hover:border-red-400 rounded text-xs font-medium text-red-700 shadow-sm" title="Delete Selected">üóëÔ∏è Delete</button>
              </div>
            </div>
            <div id="components-list" class="space-y-1.5 max-h-96 overflow-y-auto">
              <!-- Component checkboxes will be populated here -->
            </div>
          </div>

          <!-- Export Buttons -->
          <div class="border-t border-gray-200 pt-4">
            <h5 class="text-sm font-display font-semibold text-gray-700 mb-2">üì• Export Model:</h5>
            <div class="grid grid-cols-2 gap-2">
              <button
                class="export-btn px-4 py-2 bg-white border-2 border-gray-300 rounded-lg hover:border-aqua hover:bg-aqua/5 transition-colors text-sm font-medium"
                data-format="litematic"
              >
                .litematic
              </button>
              <button
                class="export-btn px-4 py-2 bg-white border-2 border-gray-300 rounded-lg hover:border-aqua hover:bg-aqua/5 transition-colors text-sm font-medium"
                data-format="schem"
              >
                .schem
              </button>
              <button
                class="export-btn px-4 py-2 bg-white border-2 border-gray-300 rounded-lg hover:border-aqua hover:bg-aqua/5 transition-colors text-sm font-medium"
                data-format="nbt"
              >
                .nbt
              </button>
              <button
                class="export-btn px-4 py-2 bg-white border-2 border-gray-300 rounded-lg hover:border-aqua hover:bg-aqua/5 transition-colors text-sm font-medium"
                data-format="vox"
              >
                .vox
              </button>
            </div>
            <p class="text-xs text-gray-500 mt-2">Litematica & Schematic for Minecraft ‚Ä¢ NBT for structure blocks ‚Ä¢ VOX for MagicaVoxel</p>
          </div>
        </div>
      </div>

      <!-- RIGHT COLUMN: 3D Viewer (Sticky) -->
      <div class="lg:sticky lg:top-4 lg:self-start">
        <h4 class="font-display font-semibold text-lg text-gray-800 mb-3">üéÆ Your 3D Model</h4>
        <VoxelViewer containerId="live-voxel-viewer" />
        <p class="text-xs text-gray-500 mt-2 text-center">
          Left-click drag to rotate ‚Ä¢ Scroll to zoom ‚Ä¢ Right-click drag to pan
        </p>
      </div>
    </div>
  </div>

  <!-- Shared Error Display -->
  <div id="error" class="hidden p-4 bg-red-50 border border-red-200 rounded-xl text-sm text-red-700 mt-4">
    <!-- Errors will be shown here -->
  </div>

  <!-- Shared Loading Display -->
  <div id="loading" class="hidden text-center py-8 mt-4">
    <div class="inline-block animate-spin rounded-full h-8 w-8 border-4 border-aqua border-t-transparent"></div>
    <p id="loading-status" class="mt-2 text-gray-600">Generating voxel model...</p>
    <p id="loading-timer" class="mt-1 text-sm text-gray-500">Elapsed: 0s</p>
    <p id="loading-warning" class="mt-1 text-xs text-orange-600">‚ö†Ô∏è Large models can take 2-5 minutes</p>
    <button
      id="cancel-btn"
      class="mt-3 px-4 py-2 bg-red-500 hover:bg-red-600 text-white font-semibold rounded-lg transition-colors"
    >
      Cancel Generation
    </button>
  </div>
</div>

<!-- Minecraft Preview Modal Root (React will render here) -->
<div id="minecraft-modal-root"></div>

<!-- Block Palette (React Component) -->
<div id="block-palette-root"></div>

<!-- Docs Panel (React Component) -->
<div id="docs-panel-root"></div>

<script>
  // Block Palette Integration
  import { createRoot } from 'react-dom/client';
  import BlockPalette from './BlockPalette/BlockPalette.tsx';
  import { createElement } from 'react';

  let isBlockPaletteOpen = false;
  let blockPaletteRoot: any = null;

  function renderBlockPalette(isOpen: boolean) {
    const container = document.getElementById('block-palette-root');
    if (!container) return;

    if (!blockPaletteRoot) {
      blockPaletteRoot = createRoot(container);
    }

    blockPaletteRoot.render(
      createElement(BlockPalette, {
        isOpen: isOpen,
        onClose: () => {
          isBlockPaletteOpen = false;
          renderBlockPalette(false);
        },
        onSelectBlock: (blockId: string) => {
          insertBlockIntoEditor(blockId);
          isBlockPaletteOpen = false;
          renderBlockPalette(false);
        }
      })
    );
  }

  function insertBlockIntoEditor(blockId: string) {
    const codeEditor = document.getElementById('code-editor') as HTMLTextAreaElement;
    if (!codeEditor) return;

    const start = codeEditor.selectionStart;
    const end = codeEditor.selectionEnd;
    const value = codeEditor.value;

    // Insert block ID (with quotes, no prefix needed)
    const insertion = `"${blockId}"`;
    const newValue = value.substring(0, start) + insertion + value.substring(end);

    codeEditor.value = newValue;

    // Move cursor after insertion
    const newCursorPos = start + insertion.length;
    codeEditor.setSelectionRange(newCursorPos, newCursorPos);
    codeEditor.focus();
  }

  // Toggle blocks button handler
  const toggleBlocksBtn = document.getElementById('toggle-blocks-btn');
  toggleBlocksBtn?.addEventListener('click', () => {
    isBlockPaletteOpen = !isBlockPaletteOpen;
    renderBlockPalette(isBlockPaletteOpen);
  });

  // Initialize (render closed)
  renderBlockPalette(false);
</script>

<script>
  // Docs Panel Integration
  import { createRoot } from 'react-dom/client';
  import DocsPanel from './DocsPanel/DocsPanel.tsx';
  import { createElement } from 'react';

  let isDocsPanelOpen = false;
  let docsPanelRoot: any = null;

  function renderDocsPanel(isOpen: boolean) {
    const container = document.getElementById('docs-panel-root');
    if (!container) return;

    if (!docsPanelRoot) {
      docsPanelRoot = createRoot(container);
    }

    docsPanelRoot.render(
      createElement(DocsPanel, {
        isOpen: isOpen,
        onClose: () => {
          isDocsPanelOpen = false;
          renderDocsPanel(false);
        }
      })
    );
  }

  // Toggle docs button handler
  const toggleDocsBtn = document.getElementById('toggle-docs-btn');
  toggleDocsBtn?.addEventListener('click', () => {
    isDocsPanelOpen = !isDocsPanelOpen;
    renderDocsPanel(isDocsPanelOpen);
  });

  // Initialize (render closed)
  renderDocsPanel(false);
</script>

<script>
  // Block Autocomplete Integration
  import { BlockAutocomplete } from './BlockAutocomplete.ts';
  import blocksData from '../../public/blocks.json';

  let autocompleteInstance: BlockAutocomplete | null = null;

  // Initialize autocomplete when code editor is ready
  function initializeAutocomplete() {
    const codeEditor = document.getElementById('code-editor') as HTMLTextAreaElement;
    if (!codeEditor) {
      console.log('[Autocomplete] Code editor not found, will retry...');
      return;
    }

    // Destroy existing instance if any
    if (autocompleteInstance) {
      autocompleteInstance.destroy();
    }

    // Create new autocomplete instance
    autocompleteInstance = new BlockAutocomplete({
      blocks: blocksData.blocks,
      textarea: codeEditor,
      onSelect: (blockId: string) => {
        console.log('[Autocomplete] Block selected:', blockId);
      }
    });

    console.log('[Autocomplete] Initialized with', blocksData.blocks.length, 'blocks');
  }

  // Watch for code editor to become visible
  const observer = new MutationObserver((mutations) => {
    const codeEditorSection = document.getElementById('code-editor-section');
    if (codeEditorSection && !codeEditorSection.classList.contains('hidden')) {
      if (!autocompleteInstance) {
        initializeAutocomplete();
      }
    }
  });

  // Start observing when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      const codeEditorSection = document.getElementById('code-editor-section');
      if (codeEditorSection) {
        observer.observe(codeEditorSection, { attributes: true, attributeFilter: ['class'] });
      }

      // Also try to initialize immediately if editor is already visible
      initializeAutocomplete();
    });
  } else {
    const codeEditorSection = document.getElementById('code-editor-section');
    if (codeEditorSection) {
      observer.observe(codeEditorSection, { attributes: true, attributeFilter: ['class'] });
    }

    // Try to initialize immediately
    initializeAutocomplete();
  }
</script>

<script>
  // Shared function to display component catalog and stats
  // Setup placement mode toggle buttons (shared between Generate and Visualize paths)
  function setupPlacementModeButtons(viewer: any) {
    const displayBtn = document.getElementById('mode-display-btn');
    const blocksBtn = document.getElementById('mode-blocks-btn');

    console.log('[Setup] Setting up placement mode buttons...', { displayBtn: !!displayBtn, blocksBtn: !!blocksBtn });

    if (displayBtn && blocksBtn) {
      console.log('[Setup] Attaching event listeners to placement mode buttons');

      // Remove old listeners by cloning and replacing (simple way to avoid duplicates)
      const newDisplayBtn = displayBtn.cloneNode(true);
      const newBlocksBtn = blocksBtn.cloneNode(true);
      displayBtn.parentNode?.replaceChild(newDisplayBtn, displayBtn);
      blocksBtn.parentNode?.replaceChild(newBlocksBtn, blocksBtn);

      let currentMode = 'display';

      newDisplayBtn.addEventListener('click', () => {
        console.log('[UI] Display button clicked, currentMode:', currentMode);
        if (currentMode !== 'display') {
          currentMode = 'display';

          // Update button styles
          newDisplayBtn.classList.add('bg-aqua', 'text-white');
          newDisplayBtn.classList.remove('text-gray-700', 'hover:bg-gray-50');
          newBlocksBtn.classList.remove('bg-aqua', 'text-white');
          newBlocksBtn.classList.add('text-gray-700', 'hover:bg-gray-50');

          // Switch mode
          viewer.setPlacementMode('display');
        }
      });

      newBlocksBtn.addEventListener('click', () => {
        console.log('[UI] Real Blocks button clicked, currentMode:', currentMode);
        if (currentMode !== 'blocks') {
          currentMode = 'blocks';

          // Update button styles
          newBlocksBtn.classList.add('bg-aqua', 'text-white');
          newBlocksBtn.classList.remove('text-gray-700', 'hover:bg-gray-50');
          newDisplayBtn.classList.remove('bg-aqua', 'text-white');
          newDisplayBtn.classList.add('text-gray-700', 'hover:bg-gray-50');

          // Switch mode
          viewer.setPlacementMode('blocks');
        } else {
          console.log('[UI] Already in blocks mode, ignoring click');
        }
      });

      console.log('[Setup] Event listeners attached successfully');
    } else {
      console.error('[Setup] Could not find placement mode buttons!');
    }
  }

  function displayComponentCatalog(data: any, viewer: any) {
    const statsDiv = document.getElementById('model-stats');
    if (!statsDiv) return;

    // Clear previous catalog
    statsDiv.innerHTML = '';

    if (data.components && data.components.length > 0) {
      let catalogHtml = '<div class="col-span-2 p-3 bg-blue-50 rounded-lg border border-blue-200">';
      catalogHtml += '<div class="flex items-center justify-between mb-2">';
      catalogHtml += '<div>';
      catalogHtml += '<div class="text-sm font-semibold text-blue-900">üì¶ Component Catalog</div>';
      catalogHtml += '<div class="text-xs text-gray-600">üß± ' + (data.blocks?.length || 0).toLocaleString() + ' blocks</div>';
      catalogHtml += '</div>';
      catalogHtml += '<div class="flex gap-1">';
      catalogHtml += '<button id="delete-selected-components" class="hidden text-xs px-2 py-1 bg-red-200 hover:bg-red-300 rounded" title="Delete selected components">Delete</button>';
      catalogHtml += '<button id="show-all-components" class="hidden text-xs px-2 py-1 bg-green-200 hover:bg-green-300 rounded" title="Show all hidden components">Show All</button>';
      catalogHtml += '<button id="clear-component-selection" class="hidden text-xs px-2 py-1 bg-blue-200 hover:bg-blue-300 rounded">Clear Selection</button>';
      catalogHtml += '</div>';
      catalogHtml += '</div>';
      catalogHtml += '<div class="text-xs space-y-1" id="component-list">';

      data.components.forEach((comp: any) => {
        const icon = comp.type === 'sphere' ? '‚ö´' :
                    comp.type === 'cylinder' ? 'üîµ' :
                    comp.type === 'cone' ? 'üî∫' :
                    comp.type === 'box' ? 'üì¶' : 'üîπ';

        catalogHtml += `<div class="component-item flex items-start gap-2 p-2 hover:bg-blue-100 rounded border border-transparent" data-component-id="${comp.id}">`;
        catalogHtml += `<input type="checkbox" class="component-checkbox mt-1" data-component-id="${comp.id}">`;
        catalogHtml += `<button class="visibility-toggle text-lg hover:scale-125 transition-transform" data-component-id="${comp.id}" title="Toggle visibility">üëÅÔ∏è</button>`;
        catalogHtml += `<span>${icon}</span>`;
        catalogHtml += `<div class="flex-1 cursor-pointer component-label" data-component-id="${comp.id}">`;
        catalogHtml += `<span class="font-mono font-semibold text-blue-800">${comp.id}</span>`;
        catalogHtml += `<span class="text-gray-500 ml-1">(${comp.type})</span>`;
        if (comp.description) {
          catalogHtml += `<div class="text-gray-600 italic">${comp.description}</div>`;
        }
        catalogHtml += `</div>`;
        catalogHtml += `</div>`;
      });

      catalogHtml += '</div>';
      catalogHtml += '</div>';
      statsDiv.innerHTML += catalogHtml;

      // Attach event handlers (same as before)
      attachComponentHandlers(viewer);
    }
  }

  // Shared function to setup global transform controls
  function setupGlobalTransformControls(viewer: any) {
    // Global rotation button handlers
    document.querySelectorAll('.global-rotate-btn').forEach(btn => {
      btn.addEventListener('click', function(e) {
        e.stopPropagation();
        const axis = (this as HTMLElement).getAttribute('data-axis') as 'x' | 'y' | 'z';
        const degrees = parseInt((this as HTMLElement).getAttribute('data-degrees') || '90');
        const viewer = (window as any).currentLiveViewer;

        // Get all selected component IDs
        const checkedIds: string[] = [];
        document.querySelectorAll('.component-checkbox:checked').forEach(cb => {
          const id = (cb as HTMLElement).getAttribute('data-component-id');
          if (id) checkedIds.push(id);
        });

        if (viewer && checkedIds.length > 0 && axis) {
          viewer.rotateComponents(checkedIds, axis, degrees);
          // Track manual edit for export
          checkedIds.forEach(id => {
            recordManualEdit({
              type: 'rotate',
              componentId: id,
              axis: axis,
              degrees: degrees
            });
          });
        }
      });
    });

    // Global movement button handlers
    document.querySelectorAll('.global-move-btn').forEach(btn => {
      btn.addEventListener('click', function(e) {
        e.stopPropagation();
        const axis = (this as HTMLElement).getAttribute('data-axis') as 'x' | 'y' | 'z';
        const amount = parseFloat((this as HTMLElement).getAttribute('data-amount') || '0.25');
        const viewer = (window as any).currentLiveViewer;

        // Get all selected component IDs
        const checkedIds: string[] = [];
        document.querySelectorAll('.component-checkbox:checked').forEach(cb => {
          const id = (cb as HTMLElement).getAttribute('data-component-id');
          if (id) checkedIds.push(id);
        });

        if (viewer && checkedIds.length > 0 && axis) {
          viewer.moveComponents(checkedIds, axis, amount);
          // Track manual edit for export
          checkedIds.forEach(id => {
            recordManualEdit({
              type: 'move',
              componentId: id,
              axis: axis,
              amount: amount
            });
          });
        }
      });
    });
  }

  // Shared function to attach component event handlers
  function attachComponentHandlers(viewer: any) {
    // Add click handlers for visibility toggles
    document.querySelectorAll('.visibility-toggle').forEach(btn => {
      btn.addEventListener('click', function(e) {
        e.stopPropagation();
        const componentId = (this as HTMLElement).getAttribute('data-component-id');
        if (viewer && componentId) {
          viewer.toggleComponentVisibility(componentId);
          const isHidden = viewer.hiddenComponents.has(componentId);
          (this as HTMLElement).textContent = isHidden ? 'üëÅÔ∏è‚Äçüó®Ô∏è' : 'üëÅÔ∏è';
          (this as HTMLElement).style.opacity = isHidden ? '0.3' : '1';
          // Update button visibility
          updateCatalogButtonVisibility();
        }
      });
    });

    // Add click handlers for component selection
    document.querySelectorAll('.component-label').forEach(label => {
      label.addEventListener('click', function() {
        const componentId = (this as HTMLElement).getAttribute('data-component-id');
        const checkbox = document.querySelector(`.component-checkbox[data-component-id="${componentId}"]`) as HTMLInputElement;
        if (checkbox) {
          checkbox.checked = !checkbox.checked;
          checkbox.dispatchEvent(new Event('change'));
        }
      });
    });

    // Show All button
    document.getElementById('show-all-components')?.addEventListener('click', function() {
      if (viewer) {
        viewer.showAllComponents();
        document.querySelectorAll('.visibility-toggle').forEach(btn => {
          (btn as HTMLElement).textContent = 'üëÅÔ∏è';
          (btn as HTMLElement).style.opacity = '1';
        });
        // Update button visibility
        updateCatalogButtonVisibility();
      }
    });

    // Function to update button visibility based on current state
    function updateCatalogButtonVisibility() {
      const deleteBtn = document.getElementById('delete-selected-components');
      const showAllBtn = document.getElementById('show-all-components');
      const clearSelectionBtn = document.getElementById('clear-component-selection');

      // Count selected components
      const selectedCount = document.querySelectorAll('.component-checkbox:checked').length;

      // Count hidden components (visibility toggle buttons with low opacity)
      const hiddenCount = Array.from(document.querySelectorAll('.visibility-toggle')).filter(
        btn => (btn as HTMLElement).style.opacity === '0.3'
      ).length;

      // Show/hide buttons based on state
      if (deleteBtn) {
        if (selectedCount > 0) {
          deleteBtn.classList.remove('hidden');
        } else {
          deleteBtn.classList.add('hidden');
        }
      }

      if (clearSelectionBtn) {
        if (selectedCount > 0) {
          clearSelectionBtn.classList.remove('hidden');
        } else {
          clearSelectionBtn.classList.add('hidden');
        }
      }

      if (showAllBtn) {
        if (hiddenCount > 0) {
          showAllBtn.classList.remove('hidden');
        } else {
          showAllBtn.classList.add('hidden');
        }
      }
    }

    // Checkbox change handler
    document.querySelectorAll('.component-checkbox').forEach(checkbox => {
      checkbox.addEventListener('change', function() {
        const componentId = (this as HTMLElement).getAttribute('data-component-id');
        const item = (this as HTMLElement).closest('.component-item');

        if ((this as HTMLInputElement).checked) {
          if (item) {
            item.classList.add('border-orange-500', 'bg-orange-50');
            item.classList.remove('border-transparent');
          }
        } else {
          if (item) {
            item.classList.remove('border-orange-500', 'bg-orange-50');
            item.classList.add('border-transparent');
          }
        }

        const checkedIds: string[] = [];
        document.querySelectorAll('.component-checkbox:checked').forEach(cb => {
          const id = (cb as HTMLElement).getAttribute('data-component-id');
          if (id) checkedIds.push(id);
        });

        const globalTransformControls = document.getElementById('global-transform-controls');

        if (checkedIds.length > 0) {
          if (globalTransformControls) globalTransformControls.classList.remove('hidden');
        } else {
          if (globalTransformControls) globalTransformControls.classList.add('hidden');
        }

        if (viewer) {
          if (checkedIds.length === 0) {
            viewer.clearSelection();
          } else {
            viewer.selectMultipleComponents(checkedIds);
          }
        }

        // Update button visibility
        updateCatalogButtonVisibility();
      });
    });

    // Delete button
    document.getElementById('delete-selected-components')?.addEventListener('click', function() {
      if (!viewer) return;

      const checkedIds: string[] = [];
      document.querySelectorAll('.component-checkbox:checked').forEach(cb => {
        const id = (cb as HTMLElement).getAttribute('data-component-id');
        if (id) checkedIds.push(id);
      });

      if (checkedIds.length === 0) {
        alert('No components selected');
        return;
      }

      if (confirm(`Delete ${checkedIds.length} component(s)?`)) {
        viewer.deleteComponents(checkedIds);
        // Track manual edits for export
        checkedIds.forEach(id => {
          recordManualEdit({
            type: 'delete',
            componentId: id
          });
          const item = document.querySelector(`.component-item[data-component-id="${id}"]`);
          if (item) item.remove();
        });
        // Update button visibility
        updateCatalogButtonVisibility();
      }
    });

    // Clear selection button
    document.getElementById('clear-component-selection')?.addEventListener('click', function() {
      if (viewer) {
        viewer.clearSelection();
        document.querySelectorAll('.component-checkbox').forEach(cb => {
          (cb as HTMLInputElement).checked = false;
        });

        const globalTransformControls = document.getElementById('global-transform-controls');
        if (globalTransformControls) globalTransformControls.classList.add('hidden');

        document.querySelectorAll('.component-item').forEach(el => {
          el.classList.remove('border-blue-500', 'bg-blue-100', 'border-orange-500', 'bg-orange-50');
          el.classList.add('border-transparent');
        });

        // Update button visibility
        updateCatalogButtonVisibility();
      }
    });
  }

  // Code editor state
  let currentCode = '';
  let originalCode = '';
  const codeEditorSection = document.getElementById('code-editor-section');
  const codeEditor = document.getElementById('code-editor') as HTMLTextAreaElement;
  const regenerateBtn = document.getElementById('regenerate-btn') as HTMLButtonElement;
  const resetCodeBtn = document.getElementById('reset-code-btn') as HTMLButtonElement;

  // Track manual edits for export
  let manualEdits: Array<{type: string, componentId?: string, axis?: string, amount?: number, degrees?: number}> = [];

  function recordManualEdit(edit: any) {
    manualEdits.push(edit);
    // Show export button and warning
    const exportBtn = document.getElementById('export-manual-edits-btn');
    const warning = document.getElementById('manual-edits-warning');
    if (exportBtn) exportBtn.classList.remove('hidden');
    if (warning) warning.classList.remove('hidden');
  }

  function clearManualEdits() {
    manualEdits = [];
    const exportBtn = document.getElementById('export-manual-edits-btn');
    const warning = document.getElementById('manual-edits-warning');
    if (exportBtn) exportBtn.classList.add('hidden');
    if (warning) warning.classList.add('hidden');
  }

  // Helper function to show code editor with code
  function showCodeEditor(code: string) {
    currentCode = code;
    originalCode = code;
    if (codeEditor) {
      codeEditor.value = code;
    }
    if (codeEditorSection) {
      codeEditorSection.classList.remove('hidden');
    }
  }

  // Helper function to execute code and display result
  async function executeAndDisplay(pythonCode: string, fromEditor = false) {
    const resultDiv = document.getElementById('result');
    const errorDiv = document.getElementById('error');
    const loadingDiv = document.getElementById('loading');

    // Show loading
    loadingDiv?.classList.remove('hidden');
    resultDiv?.classList.add('hidden');
    errorDiv?.classList.add('hidden');

    try {
      const { executeVoxelCode, setStatusCallback, cancelExecution } = await import('../utils/pyodide-executor');

      // Setup status callback
      const loadingStatus = document.getElementById('loading-status');
      const loadingWarning = document.getElementById('loading-warning');
      const loadingTimer = document.getElementById('loading-timer');
      const cancelBtn = document.getElementById('cancel-btn');

      // Start timer
      const startTime = Date.now();
      const timerInterval = setInterval(() => {
        const elapsed = Math.floor((Date.now() - startTime) / 1000);
        if (loadingTimer) {
          loadingTimer.textContent = `Elapsed: ${elapsed}s`;
        }
      }, 1000);

      // Setup cancel button
      let cancelled = false;
      const handleCancel = async () => {
        cancelled = true;
        if (cancelBtn) {
          cancelBtn.textContent = 'Cancelling...';
          cancelBtn.disabled = true;
        }
        await cancelExecution();
        clearInterval(timerInterval);
      };

      if (cancelBtn) {
        cancelBtn.addEventListener('click', handleCancel, { once: true });
      }

      setStatusCallback((status) => {
        if (loadingStatus) loadingStatus.textContent = status;
        if (status.includes('Executing') && loadingWarning) {
          loadingWarning.classList.remove('hidden');
        }
      });

      console.log('[Execute] Running Python code...');
      const data = await executeVoxelCode(pythonCode, 300000);

      // Clear timer and cancel button
      clearInterval(timerInterval);
      if (cancelBtn) {
        cancelBtn.removeEventListener('click', handleCancel);
        cancelBtn.textContent = 'Cancel Generation';
        cancelBtn.disabled = false;
      }

      setStatusCallback(null);

      if (cancelled) {
        throw new Error('Generation cancelled by user');
      }

      if (data.error) {
        throw new Error(data.error);
      }

      // Show code editor if not from editor (i.e., from Generate or Paste)
      if (!fromEditor) {
        showCodeEditor(pythonCode);
      }

      // Show result
      if (resultDiv) {
        resultDiv.classList.remove('hidden');

        const voxelData = data.blocks;
        if (!voxelData || voxelData.length === 0) {
          throw new Error('No blocks generated');
        }

        // Destroy old viewer if exists
        if ((window as any).currentLiveViewer) {
          (window as any).currentLiveViewer.destroy();
        }

        // Clear manual edits when regenerating (fresh start)
        clearManualEdits();

        // Load into 3D viewer
        const viewer = new (window as any).VoxelViewer('live-voxel-viewer');
        viewer.loadVoxels(voxelData, data.components || [], 'display');
        (window as any).currentLiveViewer = viewer;

        // Setup UI
        const placementToggle = document.getElementById('placement-mode-toggle');
        if (placementToggle) {
          placementToggle.classList.remove('hidden');
          placementToggle.classList.add('flex');
        }

        // Setup placement mode buttons
        setupPlacementModeButtons(viewer);

        // Setup undo/redo buttons
        const undoBtn = document.getElementById('undo-btn');
        const redoBtn = document.getElementById('redo-btn');

        if (undoBtn) {
          undoBtn.onclick = () => {
            viewer.undo();
            // Update block count display after undo
            const blockCountEl = document.querySelector('.text-xs.text-gray-600');
            if (blockCountEl) {
              const blockCount = viewer.voxelData.length;
              blockCountEl.textContent = 'üß± ' + blockCount.toLocaleString() + ' blocks';
            }
          };
        }

        if (redoBtn) {
          redoBtn.onclick = () => {
            viewer.redo();
            // Update block count display after redo
            const blockCountEl = document.querySelector('.text-xs.text-gray-600');
            if (blockCountEl) {
              const blockCount = viewer.voxelData.length;
              blockCountEl.textContent = 'üß± ' + blockCount.toLocaleString() + ' blocks';
            }
          };
        }

        displayComponentCatalog(data, viewer);
        setupGlobalTransformControls(viewer);

        // Update currentBlocks for export/preview
        currentBlocks = voxelData;

        console.log(`Loaded ${voxelData.length} blocks`);
      }
    } catch (error: any) {
      if (errorDiv) {
        errorDiv.textContent = error.message;
        errorDiv.classList.remove('hidden');
      }
    } finally {
      loadingDiv?.classList.add('hidden');
      document.getElementById('loading-warning')?.classList.add('hidden');
    }
  }

  // Create button handler
  const createBtn = document.getElementById('create-btn');
  createBtn?.addEventListener('click', async () => {
    try {
      // Fetch starter template
      const response = await fetch('/starter-template.py');
      const template = await response.text();

      // Show code editor with template
      showCodeEditor(template);

      // Scroll to editor
      codeEditorSection?.scrollIntoView({ behavior: 'smooth' });
    } catch (error) {
      console.error('Failed to load starter template:', error);
      alert('Failed to load starter template');
    }
  });

  // Regenerate button handler
  regenerateBtn?.addEventListener('click', async () => {
    if (!codeEditor || !codeEditor.value.trim()) {
      alert('Please write some code first!');
      return;
    }

    regenerateBtn.disabled = true;
    try {
      await executeAndDisplay(codeEditor.value, true);
      currentCode = codeEditor.value;
    } finally {
      regenerateBtn.disabled = false;
    }
  });

  // Reset button handler
  resetCodeBtn?.addEventListener('click', () => {
    if (confirm('Reset code to original? Your changes will be lost.')) {
      if (codeEditor) {
        codeEditor.value = originalCode;
      }
    }
  });

  // Export manual edits as code
  const exportManualEditsBtn = document.getElementById('export-manual-edits-btn');
  exportManualEditsBtn?.addEventListener('click', () => {
    if (manualEdits.length === 0) {
      alert('No manual edits to export!');
      return;
    }

    // Generate Python code from manual edits
    let exportedCode = '\n\n# Manual edits applied in 3D viewer:\n';
    exportedCode += '# (You can integrate these into your generate() function)\n\n';

    manualEdits.forEach((edit, idx) => {
      if (edit.type === 'rotate') {
        exportedCode += `# Rotate component '${edit.componentId}' around ${edit.axis.toUpperCase()} axis by ${edit.degrees}¬∞\n`;
        exportedCode += `# (Apply rotation transformation to component blocks)\n\n`;
      } else if (edit.type === 'move') {
        exportedCode += `# Move component '${edit.componentId}' ${edit.amount > 0 ? '+' : ''}${edit.amount} along ${edit.axis.toUpperCase()} axis\n`;
        exportedCode += `# (Add ${edit.amount} to all ${edit.axis} coordinates in component)\n\n`;
      } else if (edit.type === 'delete') {
        exportedCode += `# Delete component '${edit.componentId}'\n`;
        exportedCode += `# (Remove this component from the components list)\n\n`;
      }
    });

    // Append to code editor
    if (codeEditor) {
      codeEditor.value += exportedCode;
      codeEditor.scrollTop = codeEditor.scrollHeight; // Scroll to bottom
      alert(`Exported ${manualEdits.length} manual edit(s) as code comments. You can now integrate them into your generate() function.`);
    }
  });

  // Live demo functionality (Generate button)
  const generateBtn = document.getElementById('generate-btn') as HTMLButtonElement;
  const voxelInput = document.getElementById('voxel-input') as HTMLInputElement;
  const complexitySelect = document.getElementById('complexity-select') as HTMLSelectElement;
  const resultDiv = document.getElementById('result');
  const errorDiv = document.getElementById('error');
  const loadingDiv = document.getElementById('loading');
  const rateLimitInfo = document.getElementById('rate-limit-info');

  generateBtn?.addEventListener('click', async () => {
    const prompt = voxelInput?.value.trim();
    const complexity = complexitySelect?.value || 'medium';

    if (!prompt) {
      alert('Please enter what you want to create!');
      return;
    }

    generateBtn.disabled = true;

    try {
      // Show loading state
      loadingDiv?.classList.remove('hidden');
      resultDiv?.classList.add('hidden');
      errorDiv?.classList.add('hidden');

      // Fetch AI-generated Python code from server
      const response = await fetch('/api/generate-voxel', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ prompt, size: complexity }),
      });

      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.error || 'Generation failed');
      }

      // Execute the AI-generated code using our helper (shows code editor automatically)
      const { executeVoxelCode, setStatusCallback, cancelExecution } = await import('../utils/pyodide-executor');

      // Setup status callback to show execution progress
      const loadingStatus = document.getElementById('loading-status');
      const loadingWarning = document.getElementById('loading-warning');
      const loadingTimer = document.getElementById('loading-timer');
      const cancelBtn = document.getElementById('cancel-btn');

      // Start timer
      const startTime = Date.now();
      const timerInterval = setInterval(() => {
        const elapsed = Math.floor((Date.now() - startTime) / 1000);
        if (loadingTimer) {
          loadingTimer.textContent = `Elapsed: ${elapsed}s`;
        }
      }, 1000);

      // Setup cancel button
      let cancelled = false;
      const handleCancel = async () => {
        cancelled = true;
        if (cancelBtn) {
          cancelBtn.textContent = 'Cancelling...';
          cancelBtn.disabled = true;
        }
        await cancelExecution();
        clearInterval(timerInterval);
      };

      if (cancelBtn) {
        cancelBtn.addEventListener('click', handleCancel, { once: true });
      }

      setStatusCallback((status) => {
        if (loadingStatus) {
          loadingStatus.textContent = status;
        }
        // Show warning when executing code
        if (status.includes('Executing') && loadingWarning) {
          loadingWarning.classList.remove('hidden');
        }
      });

      console.log('[Generate] Executing AI-generated code with Pyodide...');
      const executionResult = await executeVoxelCode(data.code, 300000); // 5 minute timeout for massive models

      // Clear timer and cancel button
      clearInterval(timerInterval);
      if (cancelBtn) {
        cancelBtn.removeEventListener('click', handleCancel);
        cancelBtn.textContent = 'Cancel Generation';
        cancelBtn.disabled = false;
      }

      // Clear status callback
      setStatusCallback(null);

      // Check if cancelled
      if (cancelled) {
        throw new Error('Generation cancelled by user');
      }

      if (executionResult.error) {
        throw new Error(executionResult.error);
      }

      // Show result
      if (resultDiv) {
        resultDiv.classList.remove('hidden');

        // Load voxel data into 3D viewer
        try {
          const voxelData = executionResult.blocks;

          if (!voxelData || voxelData.length === 0) {
            throw new Error('No blocks generated');
          }

          // Update currentBlocks for export/preview functionality
          currentBlocks = voxelData;

          // Destroy old viewer if it exists
          if ((window as any).currentLiveViewer) {
            (window as any).currentLiveViewer.destroy();
          }

          // Load into 3D viewer
          const viewer = new (window as any).VoxelViewer('live-voxel-viewer');

          // Default to 'display' mode
          const placementMode = 'display';
          viewer.loadVoxels(voxelData, executionResult.components, placementMode);

          // Store viewer instance globally for component selection
          (window as any).currentLiveViewer = viewer;

          // Show and setup placement mode toggle
          const placementToggle = document.getElementById('placement-mode-toggle');
          if (placementToggle) {
            placementToggle.classList.remove('hidden');
            placementToggle.classList.add('flex');
          }

          // Setup placement mode buttons (shared function)
          setupPlacementModeButtons(viewer);

          // Setup undo/redo buttons
          const undoBtn = document.getElementById('undo-btn');
          const redoBtn = document.getElementById('redo-btn');

          if (undoBtn) {
            undoBtn.addEventListener('click', () => {
              viewer.undo();
              // Update block count display after undo
              const blockCountEl = document.querySelector('.text-xs.text-gray-600');
              if (blockCountEl) {
                const blockCount = viewer.voxelData.length;
                blockCountEl.textContent = 'üß± ' + blockCount.toLocaleString() + ' blocks';
              }
            });
          }

          if (redoBtn) {
            redoBtn.addEventListener('click', () => {
              viewer.redo();
              // Update block count display after redo
              const blockCountEl = document.querySelector('.text-xs.text-gray-600');
              if (blockCountEl) {
                const blockCount = viewer.voxelData.length;
                blockCountEl.textContent = 'üß± ' + blockCount.toLocaleString() + ' blocks';
              }
            });
          }

          // Keyboard shortcuts
          document.addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
              e.preventDefault();
              viewer.undo();
            } else if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {
              e.preventDefault();
              viewer.redo();
            }
          });

          // Display component catalog using shared function
          displayComponentCatalog(executionResult, viewer);

          // Setup global transform controls (shared function)
          setupGlobalTransformControls(viewer);

          console.log(`Loaded ${voxelData.length} blocks into viewer`);
        } catch (parseError) {
          console.error('Failed to load voxel data:', parseError);
        }
      }

      // Show code editor with the AI-generated code
      showCodeEditor(data.code);

      // Update rate limit
      if (rateLimitInfo && data.rateLimitRemaining !== undefined) {
        if (data.rateLimitRemaining === 999) {
          rateLimitInfo.textContent = '';
        } else {
          rateLimitInfo.textContent = `${data.rateLimitRemaining} generation(s) remaining this hour`;
        }
      }
    } catch (error: any) {
      if (errorDiv) {
        errorDiv.textContent = error.message;
        errorDiv.classList.remove('hidden');
      }
    } finally {
      loadingDiv?.classList.add('hidden');
      document.getElementById('loading-warning')?.classList.add('hidden');
      generateBtn.disabled = false;
    }
  });

  // Copy Prompt functionality (uses same input as Generate button)
  const copyPromptBtn = document.getElementById('copy-prompt-btn');
  const promptPreview = document.getElementById('prompt-preview');
  const pasteSection = document.getElementById('paste-section');
  const pythonCodeInput = document.getElementById('python-code-input') as HTMLTextAreaElement;
  const visualizeBtn = document.getElementById('visualize-btn') as HTMLButtonElement;

  // Copy prompt functionality
  copyPromptBtn?.addEventListener('click', async () => {
    const userInput = voxelInput?.value.trim();

    if (!userInput) {
      alert('Please enter what you want to create!');
      return;
    }

    // Get complexity level from shared selector
    const complexity = complexitySelect?.value || 'medium';

    // Fetch the exact system prompt from the API with complexity
    const response = await fetch(`/api/get-system-prompt?complexity=${complexity}`);
    const { systemPrompt } = await response.json();

    // Replace {PROMPT} placeholder with actual user input
    const fullPrompt = systemPrompt.replace('{PROMPT}', userInput);

    // Copy to clipboard
    try {
      await navigator.clipboard.writeText(fullPrompt);

      // Show preview and paste section
      promptPreview?.classList.remove('hidden');
      pasteSection?.classList.remove('hidden');
    } catch (err) {
      alert('Failed to copy. Please try again.');
    }
  });

  // Visualize functionality
  visualizeBtn?.addEventListener('click', async () => {
    const pythonCode = pythonCodeInput?.value.trim();

    if (!pythonCode) {
      alert('Please paste the Python code first!');
      return;
    }

    // Show loading, hide others (using shared divs)
    loadingDiv?.classList.remove('hidden');
    resultDiv?.classList.add('hidden');
    errorDiv?.classList.add('hidden');
    visualizeBtn.disabled = true;

    try {
      // üöÄ NEW: Execute in browser using Pyodide (client-side, instant!)
      const { executeVoxelCode, setStatusCallback, cancelExecution } = await import('../utils/pyodide-executor');

      // Setup status callback to show initialization progress
      const loadingStatus = document.getElementById('loading-status');
      const loadingWarning = document.getElementById('loading-warning');
      const loadingTimer = document.getElementById('loading-timer');
      const cancelBtn = document.getElementById('cancel-btn');

      // Start timer
      const startTime = Date.now();
      const timerInterval = setInterval(() => {
        const elapsed = Math.floor((Date.now() - startTime) / 1000);
        if (loadingTimer) {
          loadingTimer.textContent = `Elapsed: ${elapsed}s`;
        }
      }, 1000);

      // Setup cancel button
      let cancelled = false;
      const handleCancel = async () => {
        cancelled = true;
        if (cancelBtn) {
          cancelBtn.textContent = 'Cancelling...';
          cancelBtn.disabled = true;
        }
        await cancelExecution();
        clearInterval(timerInterval);
      };

      if (cancelBtn) {
        cancelBtn.addEventListener('click', handleCancel, { once: true });
      }

      setStatusCallback((status) => {
        if (loadingStatus) {
          loadingStatus.textContent = status;
        }
        // Show warning when executing code
        if (status.includes('Executing') && loadingWarning) {
          loadingWarning.classList.remove('hidden');
        }
      });

      console.log('[VoxelDemo] Executing code client-side with Pyodide...');
      const data = await executeVoxelCode(pythonCode, 300000); // 5 minute timeout for massive models

      // Clear timer and cancel button
      clearInterval(timerInterval);
      if (cancelBtn) {
        cancelBtn.removeEventListener('click', handleCancel);
        cancelBtn.textContent = 'Cancel Generation';
        cancelBtn.disabled = false;
      }

      // Clear status callback
      setStatusCallback(null);

      // Check if cancelled
      if (cancelled) {
        throw new Error('Generation cancelled by user');
      }

      if (data.error) {
        throw new Error(data.error);
      }

      // Show result (using shared result div)
      if (resultDiv) {
        resultDiv.classList.remove('hidden');

        // Load voxel data into 3D viewer (same as Live Demo)
        const voxelData = data.blocks;
        const components = data.components || [];

        if (!voxelData || voxelData.length === 0) {
          throw new Error('No blocks generated');
        }

        // Update currentBlocks for export/preview functionality
        currentBlocks = voxelData;

        // Destroy old viewer if it exists
        if ((window as any).currentLiveViewer) {
          (window as any).currentLiveViewer.destroy();
        }

        // Default to 'display' mode
        const placementMode = 'display';

        // Load into 3D viewer (using shared viewer)
        const viewer = new (window as any).VoxelViewer('live-voxel-viewer');
        viewer.loadVoxels(voxelData, components, placementMode);

        // Store viewer instance
        (window as any).currentLiveViewer = viewer;

        // Show placement mode toggle
        const placementToggle = document.getElementById('placement-mode-toggle');
        if (placementToggle) {
          placementToggle.classList.remove('hidden');
          placementToggle.classList.add('flex');
        }

        // Setup placement mode buttons (shared function)
        setupPlacementModeButtons(viewer);

        // Display component catalog using shared function
        displayComponentCatalog(data, viewer);

        // Setup global transform controls (shared function)
        setupGlobalTransformControls(viewer);

        console.log(`Loaded ${voxelData.length} blocks into viewer`);
      }

      // Show code editor with the pasted code
      showCodeEditor(pythonCode);
    } catch (error: any) {
      if (errorDiv) {
        errorDiv.textContent = error.message;
        errorDiv.classList.remove('hidden');
      }
    } finally {
      loadingDiv?.classList.add('hidden');
      document.getElementById('loading-warning')?.classList.add('hidden');
      visualizeBtn.disabled = false;
    }
  });

  // Export functionality - unified blocks tracking
  let currentBlocks: any[] = [];

  // Handle export button clicks
  document.querySelectorAll('.export-btn').forEach((btn) => {
    btn.addEventListener('click', async function(this: HTMLButtonElement) {
      const format = this.dataset.format;

      if (!format) return;

      if (!currentBlocks || currentBlocks.length === 0) {
        alert('No model to export! Generate a model first.');
        return;
      }

      // Disable button during export
      const originalText = this.textContent;
      this.disabled = true;
      this.textContent = 'Exporting...';

      try {
        const response = await fetch('/api/export-voxel', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            blocks: currentBlocks,
            format,
            name: 'VoxelModel'
          }),
        });

        if (!response.ok) {
          throw new Error('Export failed');
        }

        // Download the file
        const blob = await response.blob();
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `VoxelModel.${format}`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        // Show success feedback
        this.textContent = '‚úì Downloaded!';
        setTimeout(() => {
          this.textContent = originalText;
        }, 2000);
      } catch (error) {
        alert('Export failed. Please try again.');
        console.error('Export error:', error);
      } finally {
        this.disabled = false;
      }
    });
  });

  // Handle Minecraft Preview button
  const minecraftPreviewBtn = document.getElementById('minecraft-preview-btn');
  let currentReactRoot: any = null;

  minecraftPreviewBtn?.addEventListener('click', async (e) => {
    e.preventDefault(); // Prevent any default behavior
    e.stopPropagation(); // Stop event bubbling

    if (!currentBlocks || currentBlocks.length === 0) {
      alert('No model to preview! Generate a model first.');
      return;
    }

    // Show loading overlay IMMEDIATELY
    const loadingOverlay = document.getElementById('loading-overlay');
    const statusText = document.getElementById('status-text');
    if (loadingOverlay && statusText) {
      loadingOverlay.classList.remove('hidden');
      statusText.textContent = `Loading Minecraft preview (${currentBlocks.length.toLocaleString()} blocks)... This may take a moment.`;
    }

    // Let the loading overlay render before starting heavy work
    await new Promise(resolve => setTimeout(resolve, 50));

    // Dynamically import React and ReactDOM
    const React = await import('react');
    const ReactDOM = await import('react-dom/client');
    const { convertVoxelsToPrismarineBlocks } = await import('../utils/prismarine-converter');
    const MinecraftViewer = (await import('../components/PrismarineViewer.tsx')).default;

    // Convert blocks - ALWAYS use 'blocks' mode for Minecraft preview (shows what it actually looks like in-game)
    const prismarineBlocks = convertVoxelsToPrismarineBlocks(currentBlocks, 'blocks');

    // Get modal container
    const modalRoot = document.getElementById('minecraft-modal-root');
    if (!modalRoot) return;

    // Create or reuse root
    if (!currentReactRoot) {
      currentReactRoot = ReactDOM.createRoot(modalRoot);
    }

    // Render
    currentReactRoot.render(
      React.createElement(MinecraftViewer, {
        blocks: prismarineBlocks,
        onClose: () => {
          // Clear the modal content (but keep the root)
          currentReactRoot.render(null);
        }
      })
    );

    // Hide loading overlay after render starts (actual Three.js loading happens async)
    setTimeout(() => {
      if (loadingOverlay) {
        loadingOverlay.classList.add('hidden');
      }
    }, 1000);
  });

  // Intercept successful generations to store blocks (unified for both paths)
  const originalFetch = window.fetch;
  window.fetch = async function(input, init) {
    const response = await originalFetch(input, init);

    // Clone response to read it
    const clonedResponse = response.clone();

    // Check if this is a voxel generation (execute-python now runs client-side)
    const url = typeof input === 'string' ? input : input?.url;

    if (url && url.includes('/api/generate-voxel') && response.ok) {
      clonedResponse.json().then(data => {
        if (data.blocks) {
          currentBlocks = data.blocks;
        }
      });
    }

    return response;
  };
</script>
